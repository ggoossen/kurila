-*- buffer-read-only: t -*-

!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by autodoc.pl extracting documentation from the C source
files.

=head1 NAME

perlintern - autogenerated documentation of purely B<internal>
		 Perl functions

=head1 DESCRIPTION
X<internal Perl functions> X<interpreter functions>

This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API. In other words,
B<they are not for use in extensions>!


=head1 Functions in file pad.h


=over 8

=item CX_CURPAD_SAVE
X<CX_CURPAD_SAVE>

Save the current pad in the given context block structure.

	void	CX_CURPAD_SAVE(struct context)

=for hackers
Found in file pad.h

=item CX_CURPAD_SV
X<CX_CURPAD_SV>

Access the SV at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).

	SV *	CX_CURPAD_SV(struct context, PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_BASE_SV
X<PAD_BASE_SV>

Get the value from slot C<po> in the base (DEPTH=1) pad of a padlist

	SV *	PAD_BASE_SV(PADLIST padlist, PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_CLONE_VARS
X<PAD_CLONE_VARS>

Clone the state variables associated with running and compiling pads.

	void	PAD_CLONE_VARS(PerlInterpreter *proto_perl, CLONE_PARAMS* param)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_FLAGS
X<PAD_COMPNAME_FLAGS>

Return the flags for the current compiling pad name
at offset C<po>. Assumes a valid slot entry.

	U32	PAD_COMPNAME_FLAGS(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_GEN
X<PAD_COMPNAME_GEN>

The generation number of the name at offset C<po> in the current
compiling pad (lvalue). Note that C<SvUVX> is hijacked for this purpose.

	STRLEN	PAD_COMPNAME_GEN(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_GEN_set
X<PAD_COMPNAME_GEN_set>

Sets the generation number of the name at offset C<po> in the current
ling pad (lvalue) to C<gen>.  Note that C<SvUV_set> is hijacked for this purpose.

	STRLEN	PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_OURGV
X<PAD_COMPNAME_OURGV>

Return the gv associated with an C<our> variable.
Assumes the slot entry is a valid C<our> lexical.

	HV *	PAD_COMPNAME_OURGV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_PV
X<PAD_COMPNAME_PV>

Return the name of the current compiling pad name
at offset C<po>. Assumes a valid slot entry.

	char *	PAD_COMPNAME_PV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_TYPE
X<PAD_COMPNAME_TYPE>

Return the type (stash) of the current compiling pad name at offset
C<po>. Must be a valid name. Returns null if not typed.

	HV *	PAD_COMPNAME_TYPE(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_DUP
X<PAD_DUP>

Clone a padlist.

	void	PAD_DUP(PADLIST dstpad, PADLIST srcpad, CLONE_PARAMS* param)

=for hackers
Found in file pad.h

=item PAD_RESTORE_LOCAL
X<PAD_RESTORE_LOCAL>

Restore the old pad saved into the local variable opad by PAD_SAVE_LOCAL()

	void	PAD_RESTORE_LOCAL(PAD *opad)

=for hackers
Found in file pad.h

=item PAD_SAVE_LOCAL
X<PAD_SAVE_LOCAL>

Save the current pad to the local variable opad, then make the
current pad equal to npad

	void	PAD_SAVE_LOCAL(PAD *opad, PAD *npad)

=for hackers
Found in file pad.h

=item PAD_SAVE_SETNULLPAD
X<PAD_SAVE_SETNULLPAD>

Save the current pad then set it to null.

	void	PAD_SAVE_SETNULLPAD()

=for hackers
Found in file pad.h

=item PAD_SETSV
X<PAD_SETSV>

Set the slot at offset C<po> in the current pad to C<sv>

	SV *	PAD_SETSV(PADOFFSET po, SV* sv)

=for hackers
Found in file pad.h

=item PAD_SET_CUR
X<PAD_SET_CUR>

Set the current pad to be pad C<n> in the padlist, saving
the previous current pad. NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with

    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


	void	PAD_SET_CUR(PADLIST padlist, I32 n)

=for hackers
Found in file pad.h

=item PAD_SET_CUR_NOSAVE
X<PAD_SET_CUR_NOSAVE>

like PAD_SET_CUR, but without the save

	void	PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)

=for hackers
Found in file pad.h

=item PAD_SV
X<PAD_SV>

Get the value at offset C<po> in the current pad

	void	PAD_SV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_SVl
X<PAD_SVl>

Lightweight and lvalue version of C<PAD_SV>.
Get or set the value at offset C<po> in the current pad.
Unlike C<PAD_SV>, does not print diagnostics with -DX.
For internal use only.

	SV *	PAD_SVl(PADOFFSET po)

=for hackers
Found in file pad.h

=item SAVECLEARSV
X<SAVECLEARSV>

Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')

	void	SAVECLEARSV(SV **svp)

=for hackers
Found in file pad.h

=item SAVECOMPPAD
X<SAVECOMPPAD>

save PL_comppad and PL_curpad





	void	SAVECOMPPAD()

=for hackers
Found in file pad.h

=item SAVEPADSV
X<SAVEPADSV>

Save a pad slot (used to restore after an iteration)

XXX DAPM it would make more sense to make the arg a PADOFFSET
	void	SAVEPADSV(PADOFFSET po)

=for hackers
Found in file pad.h


=back

=head1 Magical Functions

=over 8

=item mg_localize
X<mg_localize>

Copy some of the magic from an existing SV to new localized version of
that SV. Container magic (eg %ENV, $1, tie) gets copied, value magic
doesn't (eg taint, pos).

	void	mg_localize(SV* sv, SV* nsv)

=for hackers
Found in file mg.c


=back

=head1 MRO Functions

=over 8

=item mro_get_linear_isa_c3
X<mro_get_linear_isa_c3>

Returns the C3 linearization of @ISA
the given stash.  The return value is a read-only AV*.
C<level> should be 0 (it is used internally in this
function's recursion).

You are responsible for C<SvREFCNT_inc()> on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).

	AV*	mro_get_linear_isa_c3(HV* stash, I32 level)

=for hackers
Found in file mro.c

=item mro_isa_changed_in
X<mro_isa_changed_in>

Takes the necessary steps (cache invalidations, mostly)
when the @ISA of the given package has changed.  Invoked
by the C<setisa> magic, should not need to invoke directly.

	void	mro_isa_changed_in(HV* stash)

=for hackers
Found in file mro.c


=back

=head1 Pad Data Structures

=over 8

=item CvPADLIST
X<CvPADLIST>

CV's can have CvPADLIST(cv) set to point to an AV.

For these purposes "forms" are a kind-of CV, eval""s are too (except they're
not callable at will and are always thrown away after the eval"" is done
executing). Require'd files are simply evals without any outer lexical
scope.

XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).

The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items
is managed "manual" (mostly in pad.c) rather than normal av.c rules.
The items in the AV are not SVs as for a normal AV, but other AVs:

0'th Entry of the CvPADLIST is an AV which represents the "names" or rather
the "static type information" for lexicals.

The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that
depth of recursion into the CV.
The 0'th slot of a frame AV is an AV which is @_.
other entries are storage for variables and op targets.

During compilation:
C<PL_comppad_name> is set to the names AV.
C<PL_comppad> is set to the frame AV for the frame CvDEPTH == 1.
C<PL_curpad> is set to the body of the frame AV (i.e. AvARRAY(PL_comppad)).

During execution, C<PL_comppad> and C<PL_curpad> refer to the live
frame of the currently executing sub.

Iterating over the names AV iterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef "names" (see pad_alloc()).

Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"" like
my/our variables can be.  Since they can't be looked up by "name"
but only by their index allocated at compile time (which is usually
in PL_op->op_targ), wasting a name SV for them doesn't make sense.

The SVs in the names AV have their PV being the name of the variable.
xlow+1..xhigh inclusive in the NV union is a range of cop_seq numbers for
which the name is valid.  For typed lexicals name SV is SVt_PVMG and SvSTASH
points at the type.  For C<our> lexicals, the type is also SVt_PVMG, with the
SvOURSTASH slot pointing at the stash of the associated global (so that
duplicate C<our> declarations in the same package can be detected). SvUVX is
sometimes hijacked to store the generation number during compilation.

If SvFAKE is set on the name SV, then that slot in the frame AV is
a REFCNT'ed reference to a lexical from "outside". In this case,
the name SV does not use xlow and xhigh to store a cop_seq range, since it is
in scope throughout. Instead xhigh stores some flags containing info about
the real lexical (is it declared in an anon, and is it capable of being
instantiated multiple times?), and for fake ANONs, xlow contains the index
within the parent's pad where the lexical's value is stored, to make
cloning quicker.

If the 'name' is '&' the corresponding entry in frame AV
is a CV representing a possible closure.
(SvFAKE and name of '&' is not a meaningful combination currently but could
become so if C<my sub foo {}> is implemented.)

Note that formats are treated as anon subs, and are cloned each time
write is called (if necessary).

The flag SVf_PADSTALE is cleared on lexicals each time the my() is executed,
and set on scope exit. This allows the 'Variable $x is not available' warning
to be generated in evals, such as 

    { my $x = 1; sub f { eval '$x'} } f();

For state vars, SVf_PADSTALE is overloaded to mean 'not yet initialised'

	AV *	CvPADLIST(CV *cv)

=for hackers
Found in file pad.c

=item cv_dump
X<cv_dump>

dump the contents of a CV

	void	cv_dump(const CV *cv, const char *title)

=for hackers
Found in file pad.c

=item do_dump_pad
X<do_dump_pad>

Dump the contents of a padlist

	void	do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist, int full)

=for hackers
Found in file pad.c

=item intro_my
X<intro_my>

"Introduce" my variables to visible status.

	U32	intro_my()

=for hackers
Found in file pad.c

=item pad_add_anon
X<pad_add_anon>

Add an anon code entry to the current compiling pad

	PADOFFSET	pad_add_anon(SV* sv, OPCODE op_type)

=for hackers
Found in file pad.c

=item pad_add_name
X<pad_add_name>

Create a new name and associated PADMY SV in the current pad; return the
offset.
If C<ourgv> is valid, it's an our lexical, set the SvOURGV to that value

If fake, it means we're cloning an existing entry

	PADOFFSET	pad_add_name(const char *name, GV* ourgv, bool clone)

=for hackers
Found in file pad.c

=item pad_alloc
X<pad_alloc>

Allocate a new my or tmp pad entry. For a my, simply push a null SV onto
the end of PL_comppad, but for a tmp, scan the pad from PL_padix upwards
for a slot which has no name and no active value.

	PADOFFSET	pad_alloc(I32 optype, U32 tmptype)

=for hackers
Found in file pad.c

=item pad_block_start
X<pad_block_start>

Update the pad compilation state variables on entry to a new block

	void	pad_block_start(int full)

=for hackers
Found in file pad.c

=item pad_check_dup
X<pad_check_dup>

Check for duplicate declarations: report any of:
     * a my in the current scope with the same name;
     * an our (anywhere in the pad) with the same name and the same stash
       as C<ourstash>
C<is_our> indicates that the name to check is an 'our' declaration

	void	pad_check_dup(const char* name, bool is_our, const HV* ourstash)

=for hackers
Found in file pad.c

=item pad_findlex
X<pad_findlex>

Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one.

Returns the offset in the bottom pad of the lex or the fake lex.
cv is the CV in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the IVX field of a fake namesv.

Note that pad_findlex() is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.

	PADOFFSET	pad_findlex(const char *name, PAD* padnames, PAD* pad, U32 seq)

=for hackers
Found in file pad.c

=item pad_findmy
X<pad_findmy>

Given a lexical name, try to find its offset, first in the current pad,
or failing that, in the pads of any lexically enclosing subs (including
the complications introduced by eval). If the name is found in an outer pad,
then a fake entry is added to the current pad.
Returns the offset in the current pad, or NOT_IN_PAD on failure.

	PADOFFSET	pad_findmy(const char* name)

=for hackers
Found in file pad.c

=item pad_free
X<pad_free>

Free the SV at offset po in the current pad.

	void	pad_free(PADOFFSET po)

=for hackers
Found in file pad.c

=item pad_leavemy
X<pad_leavemy>

Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.

	void	pad_leavemy()

=for hackers
Found in file pad.c

=item pad_new
X<pad_new>

Create a new compiling padlist, saving and updating the various global
vars at the same time as creating the pad itself. The following flags
can be OR'ed together:

    padnew_CLONE	this pad is for a cloned CV
    padnew_SAVE		save old globals
    padnew_SAVESUB	also save extra stuff for start of sub

	PADLIST*	pad_new(int flags, PAD *parent_padnames, PAD *parent_pad, IV parent_seq)

=for hackers
Found in file pad.c

=item pad_push
X<pad_push>

Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an @_ in slot zero.

	void	pad_push(PADLIST *padlist, int depth)

=for hackers
Found in file pad.c

=item pad_reset
X<pad_reset>

Mark all the current temporaries for reuse

	void	pad_reset()

=for hackers
Found in file pad.c

=item pad_setsv
X<pad_setsv>

Set the entry at offset po in the current pad to sv.
Use the macro PAD_SETSV() rather than calling this function directly.

	void	pad_setsv(PADOFFSET po, SV* sv)

=for hackers
Found in file pad.c

=item pad_swipe
X<pad_swipe>

Abandon the tmp in the current pad at offset po and replace with a
new one.

	void	pad_swipe(PADOFFSET po, bool refadjust)

=for hackers
Found in file pad.c

=item pad_tidy
X<pad_tidy>

Tidy up a pad after we've finished compiling it:
    * remove most stuff from the pads of anonsub prototypes;
    * give it a @_;
    * mark tmps as such.

	void	pad_tidy(padtidy_type type)

=for hackers
Found in file pad.c

=item pad_undef
X<pad_undef>

Free the padlist associated with a CV.
If parts of it happen to be current, we null the relevant
PL_*pad* global vars so that we don't have any dangling references left.
We also repoint the CvOUTSIDE of any about-to-be-orphaned
inner subs to the outer of this cv.

(This function should really be called pad_free, but the name was already
taken)

	void	pad_undef(CV* cv)

=for hackers
Found in file pad.c


=back

=head1 Per-Interpreter Variables

=over 8

=item PL_DBsingle
X<PL_DBsingle>

When Perl is run in debugging mode, with the B<-d> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
C<PL_DBsub>.

	SV *	PL_DBsingle

=for hackers
Found in file intrpvar.h

=item PL_DBsub
X<PL_DBsub>

When Perl is run in debugging mode, with the B<-d> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
C<PL_DBsingle>.

	GV *	PL_DBsub

=for hackers
Found in file intrpvar.h

=item PL_DBtrace
X<PL_DBtrace>

Trace variable used when Perl is run in debugging mode, with the B<-d>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See C<PL_DBsingle>.

	SV *	PL_DBtrace

=for hackers
Found in file intrpvar.h

=item PL_dowarn
X<PL_dowarn>

The C variable which corresponds to Perl's $^W warning variable.

	bool	PL_dowarn

=for hackers
Found in file intrpvar.h

=item PL_ofs_sv
X<PL_ofs_sv>

The output field separator - C<$,> in Perl space.

	SV*	PL_ofs_sv

=for hackers
Found in file intrpvar.h

=item PL_rs
X<PL_rs>

The input record separator - C<$/> in Perl space.

	SV*	PL_rs

=for hackers
Found in file intrpvar.h


=back

=head1 Stack Manipulation Macros

=over 8

=item djSP
X<djSP>

Declare Just C<SP>. This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<SP>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)

		djSP;

=for hackers
Found in file pp.h


=back

=head1 SV Manipulation Functions

=over 8

=item sv_add_arena
X<sv_add_arena>

Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.

	void	sv_add_arena(char *const ptr, const U32 size, const U32 flags)

=for hackers
Found in file sv.c

=item sv_free_arenas
X<sv_free_arenas>

Deallocate the memory used by all arenas. Note that all the individual SV
heads and bodies within the arenas must already have been freed.

	void	sv_free_arenas()

=for hackers
Found in file sv.c


=back

=head1 SV-Body Allocation

=over 8

=item sv_2num
X<sv_2num>

Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  You must use the C<SvNUM(sv)> macro to
access this function.

	SV*	sv_2num(SV *const sv)

=for hackers
Found in file sv.c


=back

=head1 Unicode Support

=over 8

=item find_uninit_var
X<find_uninit_var>

Find the name of the undefined variable (if any) that caused the operator o
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if it's value matches uninit_sv.
So roughly speaking, if a unary operator (such as OP_COS) generates a
warning, then following the direct child of the op may yield an
OP_PADSV or OP_GV that gives the name of the undefined variable. On the
other hand, with OP_ADD there are two branches to follow, so we only print
the variable name if we get an exact match.

The name is returned as a mortal SV.

Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.

	SV*	find_uninit_var(OP* obase, SV* uninit_sv, bool top)

=for hackers
Found in file sv.c

=item report_uninit
X<report_uninit>

Print appropriate "Use of uninitialized variable" warning

	void	report_uninit(SV* uninit_sv)

=for hackers
Found in file sv.c


=back

=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.

=head1 SEE ALSO

perlguts(1), perlapi(1)

=cut

 ex: set ro:
