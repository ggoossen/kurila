  pp.c	TODO

  substr outside of string
    $a = "ab" ; $a = substr($a, 4,5)

  Attempt to use reference as lvalue in substr 
    $a = "ab" ; $b = \$a ;  substr($b, 1,1) = $b

  uninitialized	in pp_rv2gv()
	my *b = *{ undef()}

  uninitialized	in pp_rv2sv()
	my $a = undef ; my $b = $$a

  Odd number of elements in hash list
	my $a = { 1,2,3 } ;

  Invalid type in unpack: '%c
	my $A = pack ("A,A", 1,2) ;
	my @A = unpack ("A,A", "22") ;

  Attempt to pack pointer to temporary value
	pack("p", "abc") ;

  Explicit blessing to '' (assuming package main)
	bless \[], "";

  Constant subroutine %s undefined			<<<TODO
  Constant subroutine (anonymous) undefined		<<<TODO

  Mandatory Warnings
  ------------------
  Malformed UTF-8 character

__END__
# pp.c
use warnings 'substr' ;
$a = "ab" ; 
$a = substr($a, 4,5);
no warnings 'substr' ;
$a = "ab" ; 
$a = substr($a, 4,5);
EXPECT
substr outside of string at - line 4.
########
# pp.c
use warnings 'substr' ;
$a = "ab" ; 
$b = \$a ;  
substr($b, 1,1) = "ab" ;
no warnings 'substr' ;
substr($b, 1,1) = "ab" ;
EXPECT
Attempt to use reference as lvalue in substr at - line 5.
########
# pp.c
use warnings 'uninitialized' ;
# TODO
EXPECT

########
# pp.c
use warnings 'unsafe' ;
my $a = { 1,2,3};
no warnings 'unsafe' ;
my $b = { 1,2,3};
EXPECT
Odd number of elements in hash assignment at - line 3.
########
# pp.c
use warnings 'unsafe' ;
my @a = unpack ("A,A", "22") ;
my $a = pack ("A,A", 1,2) ;
no warnings 'unsafe' ;
my @b = unpack ("A,A", "22") ;
my $b = pack ("A,A", 1,2) ;
EXPECT
Invalid type in unpack: ',' at - line 3.
Invalid type in pack: ',' at - line 4.
########
# pp.c
use warnings 'uninitialized' ;
my $a = undef ; 
my $b = $$a;
no warnings 'uninitialized' ;
my $c = $$a;
EXPECT
Use of uninitialized value in scalar dereference at - line 4.
########
# pp.c
use warnings 'unsafe' ;
sub foo { my $a = "a"; return $a . $a++ . $a++ }
my $a = pack("p", &foo) ;
no warnings 'unsafe' ;
my $b = pack("p", &foo) ;
EXPECT
Attempt to pack pointer to temporary value at - line 4.
########
# pp.c
use warnings 'unsafe' ;
bless \[], "" ;
no warnings 'unsafe' ;
bless \[], "" ;
EXPECT
Explicit blessing to '' (assuming package main) at - line 3.
########
# pp.c
use utf8 ;
$_ = "\x80  \xff" ;
reverse ;
EXPECT
Malformed UTF-8 character at - line 4.
########
# pp.c
BEGIN {
    if (ord("\t") == 5) {
        print "SKIPPED\n# Character codes differ on ebcdic machines.";
        exit 0;
    }
}
use warnings 'utf8'  ;
use utf8 ;
$_ = "\x80  \xff" ;
reverse ;
no warnings 'utf8'  ;
$_ = "\x80  \xff" ;
reverse ;
EXPECT
\x80 will produce malformed UTF-8 character; use \x{80} for that at - line 10.
\xff will produce malformed UTF-8 character; use \x{ff} for that at - line 10.
Malformed UTF-8 character at - line 11.
