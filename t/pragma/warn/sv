  sv.c	

  warn(warn_uninit);

  warn(warn_uninit);

  warn(warn_uninit);

  warn(warn_uninit);

  not_a_number(sv);

  not_a_number(sv);

  warn(warn_uninit);

  not_a_number(sv);

  warn(warn_uninit);

  not_a_number(sv);

  not_a_number(sv);

  warn(warn_uninit);

  warn(warn_uninit);

  Subroutine %s redefined	

  Invalid conversion in %s:

  Undefined value assigned to typeglob

  Mandatory Warnings
  ------------------
  Malformed UTF-8 character [sv_pos_b2u]
      my $a = rindex "a\xff bc ", "bc" ;

  Mandatory Warnings TODO
  ------------------
    Attempt to free non-arena SV: 0x%lx		[del_sv]
    Reference miscount in sv_replace()		[sv_replace]
    Attempt to free unreferenced scalar		[sv_free]
    Attempt to free temp prematurely: SV 0x%lx	[sv_free]
    semi-panic: attempt to dup freed string	[newSVsv]
    

__END__
# sv.c
use integer ;
use warning 'uninitialized' ;
$x = 1 + $a[0] ; # a
no warning 'uninitialized' ;
$x = 1 + $b[0] ; # a
EXPECT
Use of uninitialized value at - line 4.
########
# sv.c (sv_2iv)
package fred ;
sub TIESCALAR { my $x ; bless \$x}
sub FETCH { return undef }
sub STORE { return 1 }
package main ;
tie $A, 'fred' ;
use integer ;
use warning 'uninitialized' ;
$A *= 2 ;
no warning 'uninitialized' ;
$A *= 2 ;
EXPECT
Use of uninitialized value at - line 10.
########
# sv.c
use integer ;
use warning 'uninitialized' ;
my $x *= 2 ; #b 
no warning 'uninitialized' ;
my $y *= 2 ; #b 
EXPECT
Use of uninitialized value at - line 4.
########
# sv.c (sv_2uv)
package fred ;
sub TIESCALAR { my $x ; bless \$x}
sub FETCH { return undef }
sub STORE { return 1 }
package main ;
tie $A, 'fred' ;
use warning 'uninitialized' ;
$B = 0 ;
$B |= $A ;
no warning 'uninitialized' ;
$B = 0 ;
$B |= $A ;
EXPECT
Use of uninitialized value at - line 10.
########
# sv.c
use warning 'uninitialized' ;
my $Y = 1 ; 
my $x = 1 | $a[$Y] ;
no warning 'uninitialized' ;
my $Y = 1 ; 
$x = 1 | $b[$Y] ;
EXPECT
Use of uninitialized value at - line 4.
########
# sv.c
use warning 'uninitialized' ;
my $x *= 1 ; # d
no warning 'uninitialized' ;
my $y *= 1 ; # d
EXPECT
Use of uninitialized value at - line 3.
########
# sv.c
use warning 'uninitialized' ;
$x = 1 + $a[0] ; # e
no warning 'uninitialized' ;
$x = 1 + $b[0] ; # e
EXPECT
Use of uninitialized value at - line 3.
########
# sv.c (sv_2nv)
package fred ;
sub TIESCALAR { my $x ; bless \$x}
sub FETCH { return undef }
sub STORE { return 1 }
package main ;
tie $A, 'fred' ;
use warning 'uninitialized' ;
$A *= 2 ;
no warning 'uninitialized' ;
$A *= 2 ;
EXPECT
Use of uninitialized value at - line 9.
########
# sv.c
use warning 'uninitialized' ;
$x = $y + 1 ; # f
no warning 'uninitialized' ;
$x = $z + 1 ; # f
EXPECT
Use of uninitialized value at - line 3.
########
# sv.c
use warning 'uninitialized' ;
$x = chop undef ; # g
no warning 'uninitialized' ;
$x = chop undef ; # g
EXPECT
Modification of a read-only value attempted at - line 3.
########
# sv.c
use warning 'uninitialized' ;
$x = chop $y ; # h
no warning 'uninitialized' ;
$x = chop $z ; # h
EXPECT
Use of uninitialized value at - line 3.
########
# sv.c (sv_2pv)
package fred ;
sub TIESCALAR { my $x ; bless \$x}
sub FETCH { return undef }
sub STORE { return 1 }
package main ;
tie $A, 'fred' ;
use warning 'uninitialized' ;
$B = "" ;
$B .= $A ;
no warning 'uninitialized' ;
$C = "" ;
$C .= $A ;
EXPECT
Use of uninitialized value at - line 10.
########
# sv.c 
use warning 'numeric' ;
sub TIESCALAR{bless[]} ; 
sub FETCH {"def"} ; 
tie $a,"main" ; 
my $b = 1 + $a;
no warning 'numeric' ;
my $c = 1 + $a;
EXPECT
Argument "def" isn't numeric in add at - line 6.
########
# sv.c
use warning 'numeric' ;
my $x = 1 + "def" ;
no warning 'numeric' ;
my $z = 1 + "def" ;
EXPECT
Argument "def" isn't numeric in add at - line 3.
########
# sv.c
use warning 'numeric' ;
my $a = "def" ;
my $x = 1 + $a ;
no warning 'numeric' ;
my $y = 1 + $a ;
EXPECT
Argument "def" isn't numeric in add at - line 4.
########
# sv.c
use warning 'numeric' ; use integer ;
my $a = "def" ;
my $x = 1 + $a ;
no warning 'numeric' ;
my $z = 1 + $a ;
EXPECT
Argument "def" isn't numeric in i_add at - line 4.
########
# sv.c
use warning 'numeric' ;
my $x = 1 & "def" ;
no warning 'numeric' ;
my $z = 1 & "def" ;
EXPECT
Argument "def" isn't numeric in bit_and at - line 3.
########
# sv.c
use warning 'redefine' ;
sub fred {}  
sub joe {} 
*fred = \&joe ;
no warning 'redefine' ;
sub jim {} 
*jim = \&joe ;
EXPECT
Subroutine fred redefined at - line 5.
########
# sv.c
use warning 'printf' ;
open F, ">".($^O eq 'VMS'? 'NL:' : '/dev/null') ;
printf F "%q\n" ;
my $a = sprintf "%q" ;
printf F "%" ;
$a = sprintf "%" ;
printf F "%\x02" ;
$a = sprintf "%\x02" ;
no warning 'printf' ;
printf F "%q\n" ;
$a = sprintf "%q" ;
printf F "%" ;
$a = sprintf "%" ;
printf F "%\x02" ;
$a = sprintf "%\x02" ;
EXPECT
Invalid conversion in sprintf: "%q" at - line 5.
Invalid conversion in sprintf: end of string at - line 7.
Invalid conversion in sprintf: "%\002" at - line 9.
Invalid conversion in printf: "%q" at - line 4.
Invalid conversion in printf: end of string at - line 6.
Invalid conversion in printf: "%\002" at - line 8.
########
# sv.c
use warning 'unsafe' ;
*a = undef ;
no warning 'unsafe' ;
*b = undef ;
EXPECT
Undefined value assigned to typeglob at - line 3.
########
# sv.c
use utf8 ;
$^W =0 ;
{
  use warning 'utf8' ;
  my $a = rindex "a\xff bc ", "bc" ;
  no warning 'utf8' ;
  $a = rindex "a\xff bc ", "bc" ;
}
my $a = rindex "a\xff bc ", "bc" ;
EXPECT
\xff will produce malformed UTF-8 character; use \x{ff} for that at - line 6.
Malformed UTF-8 character at - line 6.
Malformed UTF-8 character at - line 10.
