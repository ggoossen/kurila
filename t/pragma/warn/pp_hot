  pp_hot.c	AOK

  Filehandle %s never opened
    $f = $a = "abc" ; print $f $a

  Filehandle %s opened only for input
    print STDIN "abc" ;

  Filehandle %s opened only for output
    print <STDOUT> ;

  print on closed filehandle %s
    close STDIN ; print STDIN "abc" ;

  uninitialized
	my $a = undef ; my @b = @$a

  uninitialized	
	my $a = undef ; my %b = %$a

  Odd number of elements in hash list
	%X = (1,2,3) ;

  Reference found where even-sized list expected 
	$X = [ 1 ..3 ];

  Read on closed filehandle %s
    close STDIN ; $a = <STDIN>;

  Deep recursion on subroutine \"%s\"
     sub fred { fred() if $a++ < 200} fred()

  Deep recursion on anonymous subroutine 
     $a = sub { &$a if $a++ < 200} &$a

__END__
# pp_hot.c
use warning 'unopened' ;
$f = $a = "abc" ; 
print $f $a;
no warning 'unopened' ;
print $f $a;
EXPECT
Filehandle main::abc never opened at - line 4.
########
# pp_hot.c
use warning 'io' ;
print STDIN "anc";
print <STDOUT>;
print <STDERR>;
open(FOO, ">&STDOUT") and print <FOO>;
print getc(STDERR);
print getc(FOO);
read(FOO,$_,1);
no warning 'io' ;
print STDIN "anc";
####################################################################
#                            N O T E                               #
# This test is known to fail on Linux and *BSD systems with glibc. #
# The glibc development team is aware of the problem, and has      #
# determined a fix for the next release of that library.           #
####################################################################
EXPECT
Filehandle main::STDIN opened only for input at - line 3.
Filehandle main::STDOUT opened only for output at - line 4.
Filehandle main::STDERR opened only for output at - line 5.
Filehandle main::FOO opened only for output at - line 6.
Filehandle main::STDERR opened only for output at - line 7.
Filehandle main::FOO opened only for output at - line 8.
Filehandle main::FOO opened only for output at - line 9.
########
# pp_hot.c
use warning 'closed' ;
close STDIN ;
print STDIN "anc";
no warning 'closed' ;
print STDIN "anc";
EXPECT
print on closed filehandle main::STDIN at - line 4.
########
# pp_hot.c
use warning 'uninitialized' ;
my $a = undef ;
my @b = @$a;
no warning 'uninitialized' ;
my @c = @$a;
EXPECT
Use of uninitialized value at - line 4.
########
# pp_hot.c
use warning 'uninitialized' ;
my $a = undef ;
my %b = %$a;
no warning 'uninitialized' ;
my %c = %$a;
EXPECT
Use of uninitialized value at - line 4.
########
# pp_hot.c
use warning 'unsafe' ;
my %X ; %X = (1,2,3) ;
no warning 'unsafe' ;
my %Y ; %Y = (1,2,3) ;
EXPECT
Odd number of elements in hash assignment at - line 3.
########
# pp_hot.c
use warning 'unsafe' ;
my %X ; %X = [1 .. 3] ;
no warning 'unsafe' ;
my %Y ; %Y = [1 .. 3] ;
EXPECT
Reference found where even-sized list expected at - line 3.
########
# pp_hot.c
use warning 'closed' ;
close STDIN ; $a = <STDIN> ;
no warning 'closed' ;
$a = <STDIN> ;
EXPECT
Read on closed filehandle main::STDIN at - line 3.
########
# pp_hot.c
use warning 'recursion' ;
sub fred 
{ 
    fred() if $a++ < 200
} 
{
  local $SIG{__WARN__} = sub {
    die "ok\n" if $_[0] =~ /^Deep recursion on subroutine "main::fred"/
  };
  fred();
}
EXPECT
ok
########
# pp_hot.c
no warning 'recursion' ;
sub fred 
{ 
    fred() if $a++ < 200
} 
{
  local $SIG{__WARN__} = sub {
    die "ok\n" if $_[0] =~ /^Deep recursion on subroutine "main::fred"/
  };
  fred();
}
EXPECT

########
# pp_hot.c
use warning 'recursion' ;
$b = sub 
{ 
    &$b if $a++ < 200
}  ;

&$b ;
EXPECT
Deep recursion on anonymous subroutine at - line 5.
########
# pp_hot.c
no warning 'recursion' ;
$b = sub 
{ 
    &$b if $a++ < 200
}  ;

&$b ;
EXPECT

