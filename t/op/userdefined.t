#!./perl

BEGIN { require './test.pl'; }
BEGIN { plan( tests => 7 ); }

use comptfunc;

# create a user defined functions.
# basic test that is called the correct number of times.

BEGIN { our $foo_called = 0; }
# BEGIN {
#     # define 'function' foo, which only executes it first argument.
#     # i.e. the opcode tree generated by foo $arg1, $arg2, ...  is something like as $arg1, $arg2, ...
#     $^H{'comptfunc'} = {
#                         foo => sub { $foo_called++; return $_[0] },
#                        };
# }
BEGIN { comptfunc::define( foo => sub { $foo_called++; $_[0] or die "no arguments"; return $_[0] } ); }

BEGIN { is $foo_called, 0; }
sub bar { foo(); }
BEGIN { is $foo_called, 1; }

is( (join '*', foo 1, 2), "1*2");

BEGIN { is $foo_called, 2; }

use B ();
use B::Generate ();

# fst $arg1, $arg2, ... evaluates only its first argument
# this leaks the OP_LIST, and the remaining items in the listop
BEGIN { comptfunc::define( fst => sub { my $first = $_[0]->first->sibling;
                                        # remove $first from the list of children of $_[0]
                                        $_[0]->first->sibling($first->sibling);
                                        $_[0]->free; undef $_[0];
                                        # free the $_[0] opcode.
                                        return $first;
                                    }
                         );
    }

$b = "oldb";
fst $a="newa", $b="notset";
is("$a-$b", "newa-oldb");

{
    BEGIN { comptfunc::define( nothing => sub { $_[0] and $_[0]->free; return B::OP->new('null', 0) } ); }
    nothing;

    eval "nothing";
    ok ! $@, "comptfunc in run-time eval";
}
eval "nothing";
like $@, qr/Bareword "nothing" not allowed/, "comptfunc lexical scoped.";


## calling a function
{
    our $x;
    sub func1 { $x++; return "func1 called" };

    BEGIN { comptfunc::define( compfunc1 => sub { my $op = shift;
                                                  my $cvop = B::SVOP->new('const', 0, *func1);
                                                  $op ||= B::LISTOP->new('list', 0, $cvop, undef);
                                                  return B::UNOP->new('entersub', 0, $op);
                                              } ); }

    is( (compfunc1), "func1 called");
}
