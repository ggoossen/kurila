Check the lexical scoping of the switch keywords.
(The actual behaviour is tested in t/op/switch.t)

__END__
# No switch; given should be a bareword.
use warnings;
print STDOUT given;
EXPECT
Bareword "given" not allowed while "strict subs" in use at - line 3.
Execution of - aborted due to compilation errors.
########
# No switch; when should be a bareword.
use warnings;
print STDOUT when;
EXPECT
Bareword "when" not allowed while "strict subs" in use at - line 3.
Execution of - aborted due to compilation errors.
########
# No switch; default should be a bareword.
use warnings;
print STDOUT default;
EXPECT
Bareword "default" not allowed while "strict subs" in use at - line 3.
Execution of - aborted due to compilation errors.
########
# No switch; break should be a bareword.
use warnings;
print STDOUT break;
EXPECT
Bareword "break" not allowed while "strict subs" in use at - line 3.
Execution of - aborted due to compilation errors.
########
# No switch; but continue is still a keyword
print STDOUT continue;
EXPECT
syntax error at - line 2, near "STDOUT continue"
Execution of - aborted due to compilation errors.
########
# Use switch; so given is a keyword
use feature 'switch';
given("okay\n") { print }
EXPECT
okay
########
# Use switch; so when is a keyword
use feature 'switch';
given(1) { when(1) { print "okay" } }
EXPECT
okay
########
# Use switch; so default is a keyword
use feature 'switch';
given(1) { default { print "okay" } }
EXPECT
okay
########
# Use switch; so break is a keyword
use feature 'switch';
break;
EXPECT
Can't "break" outside a given block at - line 3.
########
# Use switch; so continue is a keyword
use feature 'switch';
continue;
EXPECT
Can't "continue" outside a when block at - line 3.
########
# switch out of scope; given should be a bareword.
use warnings;
{ use feature 'switch';
  given (1) {print "Okay here\n";}
}
print STDOUT given;
EXPECT
Bareword "given" not allowed while "strict subs" in use at - line 6.
Execution of - aborted due to compilation errors.
########
# switch out of scope; when should be a bareword.
use warnings;
{ use feature 'switch';
  given (1) { when(1) {print "Okay here\n";} }
}
print STDOUT when;
EXPECT
Bareword "when" not allowed while "strict subs" in use at - line 6.
Execution of - aborted due to compilation errors.
########
# switch out of scope; default should be a bareword.
use warnings;
{ use feature 'switch';
  given (1) { default {print "Okay here\n";} }
}
print STDOUT default;
EXPECT
Bareword "default" not allowed while "strict subs" in use at - line 6.
Execution of - aborted due to compilation errors.
########
# switch out of scope; break should be a bareword.
use warnings;
{ use feature 'switch';
  given (1) { break }  
}
print STDOUT break;
EXPECT
Bareword "break" not allowed while "strict subs" in use at - line 6.
Execution of - aborted due to compilation errors.
########
# switch out of scope; continue should not work
{ use feature 'switch';
  given (1) { default {continue} }  
}
print STDOUT continue;
EXPECT
syntax error at - line 5, near "STDOUT continue"
Execution of - aborted due to compilation errors.
########
# C<no feature 'switch'> should work
use warnings;
use feature 'switch';
given (1) { when(1) {print "Okay here\n";} }
no feature 'switch';
print STDOUT when;
EXPECT
Bareword "when" not allowed while "strict subs" in use at - line 6.
Execution of - aborted due to compilation errors.
########
# C<no feature> should work too
use warnings;
use feature 'switch';
given (1) { when(1) {print "Okay here\n";} }
no feature;
print STDOUT when;
EXPECT
Bareword "when" not allowed while "strict subs" in use at - line 6.
Execution of - aborted due to compilation errors.
########
# Without the feature, no 'Unambiguous use of' warning:
use warnings;
@break = ($break = "break");
print ${break}, ${break[0]};
EXPECT
breakbreak
########
# With the feature, we get an 'Unambiguous use of' warning:
use warnings;
use feature 'switch';
@break = ($break = "break");
print ${break}, ${break[0]};
EXPECT
Ambiguous use of ${break} resolved to $break at - line 5.
Ambiguous use of ${break[...]} resolved to $break[...] at - line 5.
breakbreak
