  op.c		AOK

     Found = in conditional, should be ==
	1 if $a = 1 ;

     Useless use of time in void context
     Useless use of a variable in void context
     Useless use of a constant in void context
	time ;
	$a ;
	"abc"

     Useless use of sort in scalar context
	my $x = sort (2,1,3);

     Applying %s to %s will act on scalar(%s)
	my $a ; my @a = () ; my %a = () ; my $b = \@a ; my $c = \%a ;
	@a =~ m/abc/ ;
	@a =~ s/a/b/ ;
	@$b =~ m/abc/ ;
	@$b =~ s/a/b/ ;
	%a =~ m/abc/ ;
	%a =~ s/a/b/ ;
	%$c =~ m/abc/ ;
	%$c =~ s/a/b/ ;


     Parentheses missing around "my" list at -e line 1.
       my $a, $b = (1,2);
 
     Parentheses missing around "local" list at -e line 1.
       local $a, $b = (1,2);
 
     Bareword found in conditional at -e line 1.
       use warnings 'bareword'; my $x = print(ABC || 1);
 
     Value of %s may be \"0\"; use \"defined\" 
	$x = 1 if $x = ~< *FH ;
	$x = 1 while $x = ~< *FH ;

     Subroutine fred redefined at -e line 1.
       sub fred{1;} sub fred{1;}
 
     Constant subroutine %s redefined 
        sub fred() {1;} sub fred() {1;}
 
     Statement unlikely to be reached
     	(Maybe you meant system() when you said exec()?
 	exec "true" ; my $a

     defined(@array) is deprecated
     	(Maybe you should just omit the defined()?)
	my @a ; defined @a ;
	defined (@a = (1,2,3)) ;

     defined(%hash) is deprecated
     	(Maybe you should just omit the defined()?)
	my %h ; defined %h ;
    
    %s() called too early to check prototype		[Perl_peep]
        fred() ; sub fred ($$) {}


    Package `%s' not found (did you use the incorrect case?)

    Use of /g modifier is meaningless in split

    Possible precedence problem on bitwise %c operator	[Perl_ck_bitop]

    Mandatory Warnings 
    ------------------
    Prototype mismatch:		[cv_ckproto]
        sub fred() ;
        sub fred($) {}

    Runaway prototype		[newSUB]	TODO
    oops: oopsAV		[oopsAV]	TODO
    oops: oopsHV		[oopsHV]	TODO
    
__END__
# op.c
use warnings 'syntax' ;
1 if $a = 1 ;
no warnings 'syntax' ;
1 if $a = 1 ;
EXPECT
Found = in conditional, should be == at - line 3.
########
# op.c
use warnings 'void' ; close STDIN ;
my $x = sort (2,1,3);
no warnings 'void' ;
$x = sort (2,1,3);
EXPECT
Useless use of sort in scalar context at - line 3.
########
# op.c
use warnings 'void' ;
for (<@{\@(0)}) { "$_" }		# check warning isn't duplicated
no warnings 'void' ;
for (<@{\@(0)}) { "$_" }		# check warning isn't duplicated
EXPECT
Useless use of string in void context at - line 3.
########
# op.c
use warnings 'void' ;
use Config ;
BEGIN {
    if ( ! %Config{d_telldir}) {
        print <<EOM ;
SKIPPED
# telldir not present
EOM
        exit 
    }
}
telldir 1 ;		# OP_TELLDIR
no warnings 'void' ;
telldir 1 ;		# OP_TELLDIR
EXPECT
Useless use of telldir in void context at - line 13.
########
# op.c
use warnings 'void' ;
use Config ;
BEGIN {
    if ( ! %Config{d_getppid}) {
        print <<EOM ;
SKIPPED
# getppid not present
EOM
        exit 
    }
}
getppid ;		# OP_GETPPID
no warnings 'void' ;
getppid ;		# OP_GETPPID
EXPECT
Useless use of getppid in void context at - line 13.
########
# op.c
use warnings 'void' ;
use Config ;
BEGIN {
    if ( ! %Config{d_getpgrp}) {
        print <<EOM ;
SKIPPED
# getpgrp not present
EOM
        exit 
    }
}
getpgrp ;		# OP_GETPGRP
no warnings 'void' ;
getpgrp ;		# OP_GETPGRP
EXPECT
Useless use of getpgrp in void context at - line 13.
########
# op.c
use warnings 'void' ;
use Config ;
BEGIN {
    if ( ! %Config{d_times}) {
        print <<EOM ;
SKIPPED
# times not present
EOM
        exit 
    }
}
times ;			# OP_TMS
no warnings 'void' ;
times ;			# OP_TMS
EXPECT
Useless use of times in void context at - line 13.
########
# op.c
use warnings 'void' ;
use Config ;
BEGIN {
    if ( ! %Config{d_getprior} or $^O eq 'os2') { # Locks before fixpak22
        print <<EOM ;
SKIPPED
# getpriority not present
EOM
        exit 
    }
}
getpriority 1,2;	# OP_GETPRIORITY
no warnings 'void' ;
getpriority 1,2;	# OP_GETPRIORITY
EXPECT
Useless use of getpriority in void context at - line 13.
########
# op.c
use warnings 'void' ;
use Config ;
BEGIN {
    if ( ! %Config{d_getlogin}) {
        print <<EOM ;
SKIPPED
# getlogin not present
EOM
        exit 
    }
}
getlogin ;			# OP_GETLOGIN
no warnings 'void' ;
getlogin ;			# OP_GETLOGIN
EXPECT
Useless use of getlogin in void context at - line 13.
########
# op.c
use warnings 'void' ;
use Config ; BEGIN {
if ( ! %Config{d_socket}) {
    print <<EOM ;
SKIPPED
# getsockname not present
# getpeername not present
# gethostbyname not present
# gethostbyaddr not present
# gethostent not present
# getnetbyname not present
# getnetbyaddr not present
# getnetent not present
# getprotobyname not present
# getprotobynumber not present
# getprotoent not present
# getservbyname not present
# getservbyport not present
# getservent not present
EOM
    exit 
} }
getsockname STDIN ;	# OP_GETSOCKNAME
getpeername STDIN ;	# OP_GETPEERNAME
gethostbyname 1 ;	# OP_GHBYNAME
gethostbyaddr 1,2;	# OP_GHBYADDR
gethostent ;		# OP_GHOSTENT
getnetbyname 1 ;	# OP_GNBYNAME
getnetbyaddr 1,2 ;	# OP_GNBYADDR
getnetent ;		# OP_GNETENT
getprotobyname 1;	# OP_GPBYNAME
getprotobynumber 1;	# OP_GPBYNUMBER
getprotoent ;		# OP_GPROTOENT
getservbyname 1,2;	# OP_GSBYNAME
getservbyport 1,2;	# OP_GSBYPORT
getservent ;		# OP_GSERVENT

no warnings 'void' ;
getsockname STDIN ;	# OP_GETSOCKNAME
getpeername STDIN ;	# OP_GETPEERNAME
gethostbyname 1 ;	# OP_GHBYNAME
gethostbyaddr 1,2;	# OP_GHBYADDR
gethostent ;		# OP_GHOSTENT
getnetbyname 1 ;	# OP_GNBYNAME
getnetbyaddr 1,2 ;	# OP_GNBYADDR
getnetent ;		# OP_GNETENT
getprotobyname 1;	# OP_GPBYNAME
getprotobynumber 1;	# OP_GPBYNUMBER
getprotoent ;		# OP_GPROTOENT
getservbyname 1,2;	# OP_GSBYNAME
getservbyport 1,2;	# OP_GSBYPORT
getservent ;		# OP_GSERVENT
INIT {
   # some functions may not be there, so we exit without running
   exit;
}
EXPECT
Useless use of getsockname in void context at - line 24.
Useless use of getpeername in void context at - line 25.
Useless use of gethostbyname in void context at - line 26.
Useless use of gethostbyaddr in void context at - line 27.
Useless use of gethostent in void context at - line 28.
Useless use of getnetbyname in void context at - line 29.
Useless use of getnetbyaddr in void context at - line 30.
Useless use of getnetent in void context at - line 31.
Useless use of getprotobyname in void context at - line 32.
Useless use of getprotobynumber in void context at - line 33.
Useless use of getprotoent in void context at - line 34.
Useless use of getservbyname in void context at - line 35.
Useless use of getservbyport in void context at - line 36.
Useless use of getservent in void context at - line 37.
########
# op.c
use warnings 'void' ; our (@a, %a);
*a ; # OP_RV2GV
$a ; # OP_RV2SV
@a ; # OP_RV2AV
%a ; # OP_RV2HV
no warnings 'void' ;
*a ; # OP_RV2GV
$a ; # OP_RV2SV
@a ; # OP_RV2AV
%a ; # OP_RV2HV
EXPECT
Useless use of a variable in void context at - line 3.
Useless use of a variable in void context at - line 4.
Useless use of a variable in void context at - line 5.
Useless use of a variable in void context at - line 6.
########
# op.c
use warnings 'void' ;
"abc"; # OP_CONST
7 ; # OP_CONST
"x" . "y"; # optimized to OP_CONST
2 + 2; # optimized to OP_CONST
use constant U => undef;
U;
5 || print "bad\n";	# test OPpCONST_SHORTCIRCUIT
print "boo\n" if U;	# test OPpCONST_SHORTCIRCUIT

no warnings 'void' ;
"abc"; # OP_CONST
7 ; # OP_CONST
"x" . "y"; # optimized to OP_CONST
2 + 2; # optimized to OP_CONST
EXPECT
Useless use of a constant (abc) in void context at - line 3.
Useless use of a constant (7) in void context at - line 4.
Useless use of a constant (xy) in void context at - line 5.
Useless use of a constant (4) in void context at - line 6.
Useless use of a constant (undef) in void context at - line 8.
########
# op.c
use warnings 'parenthesis' ;
my $a, $b = (1,2);
my @foo,%bar,	$quux; # there's a TAB here
my $x, $y or print;
no warnings 'parenthesis' ;
my $c, $d = (1,2);
EXPECT
Parentheses missing around "my" list at - line 3.
list may not be used in scalar context at - line 3, near ");"
Parentheses missing around "my" list at - line 4.
Global symbol "%bar" requires explicit package name at - line 4, near ",%bar"
Global symbol "$quux" requires explicit package name at - line 4, near ",	$quux"
Global symbol "$y" requires explicit package name at - line 5, near ", $y "
BEGIN not safe after errors--compilation aborted at - line 6.
########
# op.c
use warnings 'parenthesis' ;
our $a, $b = (1,2);
no warnings 'parenthesis' ;
our $c, $d = (1,2);
EXPECT
Parentheses missing around "our" list at - line 3.
list may not be used in scalar context at - line 3, near ");"
BEGIN not safe after errors--compilation aborted at - line 4.
########
# op.c
our ($b, $c, $d);
use warnings 'parenthesis' ;
local $a, $b = (1,2);
local *f, *g;
no warnings 'parenthesis' ;
local $c, $d = (1,2);
EXPECT
Parentheses missing around "local" list at - line 4.
list may not be used in scalar context at - line 4, near ");"
Parentheses missing around "local" list at - line 5.
BEGIN not safe after errors--compilation aborted at - line 6.
########
# op.c
use warnings 'bareword' ;
print (ABC || 1) ;
no warnings 'bareword' ;
print (ABC || 1) ;
EXPECT
Bareword found in conditional at - line 3.
########
--FILE-- abc

--FILE--
# op.c
use warnings 'misc' ;
open FH, "<", "abc" ;
our $x;
$x = 1 if $x = ~< *FH ;
no warnings 'misc' ;
$x = 1 if $x = ~< *FH ;
EXPECT
Value of <HANDLE> construct can be "0"; test with defined() at - line 5.
########
# op.c
use warnings 'misc' ;
opendir FH, "." ;
our $x;
$x = 1 if $x = readdir FH ;
no warnings 'misc' ;
$x = 1 if $x = readdir FH ;
closedir FH ;
EXPECT
Value of readdir() operator can be "0"; test with defined() at - line 5.
########
# op.c
use warnings 'misc' ;
our $x;
$x = 1 if $x = glob("*") ;
no warnings 'misc' ;
$x = 1 if $x = glob("*") ;
EXPECT
Value of glob construct can be "0"; test with defined() at - line 4.
########
# op.c
use warnings 'misc' ;
our $x;
$x = 1 while $x = glob("*") and 0 ;
no warnings 'misc' ;
$x = 1 while $x = glob("*") and 0 ;
EXPECT
Value of glob construct can be "0"; test with defined() at - line 4.
########
# op.c
use warnings 'misc' ;
opendir FH, "." ;
our $x;
$x = 1 while $x = readdir FH and 0 ;
no warnings 'misc' ;
$x = 1 while $x = readdir FH and 0 ;
closedir FH ;
EXPECT
Value of readdir() operator can be "0"; test with defined() at - line 5.
########
# op.c
use warnings 'redefine' ;
sub fred {}
sub fred {}
no warnings 'redefine' ;
sub fred {}
EXPECT
Subroutine fred redefined at - line 4.
########
# op.c
use warnings 'redefine' ;
sub fred () { 1 }
sub fred () { 1 }
no warnings 'redefine' ;
sub fred () { 1 }
EXPECT
Constant subroutine fred redefined at - line 4.
########
# op.c
no warnings 'redefine' ;
sub fred () { 1 }
sub fred () { 2 }
EXPECT
Constant subroutine fred redefined at - line 4.
########
# op.c
no warnings 'redefine' ;
sub fred () { 1 }
*fred = sub () { 2 };
EXPECT
Constant subroutine main::fred redefined at - line 4.
########
# op.c
BEGIN {
    if ($^O eq 'MacOS') {
	print <<EOM;
SKIPPED
# no exec on Mac OS
EOM
	exit;
    }
}
use warnings 'syntax' ;
exec "$^X -e 1" ; 
my $a
EXPECT
Statement unlikely to be reached at - line 13.
	(Maybe you meant system() when you said exec()?)
 at - line 13.
########
# op.c
BEGIN {
    if ($^O eq 'MacOS') {
	print <<EOM;
SKIPPED
# no exec on Mac OS
EOM
	exit;
    }
}
no warnings 'syntax' ;
exec "$^X -e 1" ; 
my $a
EXPECT

########
# op.c [Perl_newATTRSUB]
--FILE-- abc.pm
use warnings 'void' ;
BEGIN { $| = 1; print "in begin\n"; }
CHECK { print "in check\n"; }
INIT { print "in init\n"; }
END { print "in end\n"; }
print "in mainline\n";
1;
--FILE--
use abc;
delete %INC{"abc.pm"};
require abc;
do "abc.pm";
EXPECT
in begin
in mainline
in check
in init
in begin
Too late to run CHECK block at abc.pm line 3.
    (eval) called at - line 3.
Too late to run INIT block at abc.pm line 4.
    (eval) called at - line 3.
in mainline
in begin
Too late to run CHECK block at abc.pm line 3.
    (eval) called at - line 4.
Too late to run INIT block at abc.pm line 4.
    (eval) called at - line 4.
in mainline
in end
in end
in end
########
# op.c [Perl_newATTRSUB]
--FILE-- abc.pm
no warnings 'void' ;
BEGIN { $| = 1; print "in begin\n"; }
CHECK { print "in check\n"; }
INIT { print "in init\n"; }
END { print "in end\n"; }
print "in mainline\n";
1;
--FILE--
require abc;
do "abc.pm";
EXPECT
in begin
in mainline
in begin
in mainline
in end
in end
########
# op.c
my @x;
use warnings 'syntax' ;
push(@x);
unshift(@x);
no warnings 'syntax' ;
push(@x);
unshift(@x);
EXPECT
Useless use of push with no values at - line 4.
Useless use of unshift with no values at - line 5.
########
# op.c
# 20020401 mjd@plover.com at suggestion of jfriedl@yahoo.com
use warnings 'regexp';
split m/blah/g, "blah";
no warnings 'regexp';
split m/blah/g, "blah";
EXPECT
Use of /g modifier is meaningless in split at - line 4.
########
# op.c
use warnings 'precedence'; our ($c, $d);
$a = $b ^&^ $c == $d;
$a = $b ^^^ $c != $d;
$a = $b ^|^ $c +> $d;
$a = $b +< $c ^&^ $d;
$a = $b +>= $c ^^^ $d;
$a = $b +<= $c ^|^ $d;
$a = $b <+> $c ^&^ $d;
$a ^&^= $b == $c; $a ^|^= $b == $c; $a ^^^= $b == $c; # shouldn't warn
no warnings 'precedence';
$a = $b ^&^ $c == $d;
$a = $b ^^^ $c != $d;
$a = $b ^|^ $c +> $d;
$a = $b +< $c ^&^ $d;
$a = $b +>= $c ^^^ $d;
$a = $b +<= $c ^|^ $d;
$a = $b <+> $c ^&^ $d;
EXPECT
Possible precedence problem on bitwise ^&^ operator at - line 3.
Possible precedence problem on bitwise ^^^ operator at - line 4.
Possible precedence problem on bitwise ^|^ operator at - line 5.
Possible precedence problem on bitwise ^&^ operator at - line 6.
Possible precedence problem on bitwise ^^^ operator at - line 7.
Possible precedence problem on bitwise ^|^ operator at - line 8.
Possible precedence problem on bitwise ^&^ operator at - line 9.
########
# op.c
use integer;
use warnings 'precedence'; our ($c, $d);
$a = $b ^&^ $c == $d;
$a = $b ^^^ $c != $d;
$a = $b ^|^ $c +> $d;
$a = $b +< $c ^&^ $d;
$a = $b +>= $c ^^^ $d;
$a = $b +<= $c ^|^ $d;
$a = $b <+> $c ^&^ $d;
no warnings 'precedence';
$a = $b ^&^ $c == $d;
$a = $b ^^^ $c != $d;
$a = $b ^|^ $c +> $d;
$a = $b +< $c ^&^ $d;
$a = $b +>= $c ^^^ $d;
$a = $b +<= $c ^|^ $d;
$a = $b <+> $c ^&^ $d;
EXPECT
Possible precedence problem on bitwise ^&^ operator at - line 4.
Possible precedence problem on bitwise ^^^ operator at - line 5.
Possible precedence problem on bitwise ^|^ operator at - line 6.
Possible precedence problem on bitwise ^&^ operator at - line 7.
Possible precedence problem on bitwise ^^^ operator at - line 8.
Possible precedence problem on bitwise ^|^ operator at - line 9.
Possible precedence problem on bitwise ^&^ operator at - line 10.
########
# op.c
use warnings 'deprecated';
my $x1 if 0;
my @x2 if 0;
my %x3 if 0;
my ($x4) if 0;
my ($x5,@x6, %x7) if 0;
0 && my $z1;
0 && my (%z2);
# these shouldn't warn
our $x if 0;
our $x unless 0;
if (0) { my $w1 }
if (my $w2) { $a=1 }
if ($a && (my $w3 = 1)) {$a = 2}

EXPECT
Deprecated use of my() in false conditional at - line 3.
Deprecated use of my() in false conditional at - line 4.
Deprecated use of my() in false conditional at - line 5.
Deprecated use of my() in false conditional at - line 6.
Deprecated use of my() in false conditional at - line 7.
Deprecated use of my() in false conditional at - line 8.
Deprecated use of my() in false conditional at - line 9.
########
