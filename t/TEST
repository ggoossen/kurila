#!./perl

# This is written in a peculiar style, since we're trying to avoid
# most of the constructs we'll be testing for.

$| = 1;

# Cheesy version of Getopt::Std.  Maybe we should replace it with that.
if ($#ARGV >= 0) {
    foreach my $idx (0..$#ARGV) {
	next unless $ARGV[$idx] =~ /^-(\S+)$/;
	$verbose = 1 if $1 eq 'v';
	$with_utf= 1 if $1 eq 'utf8';
	if ($1 =~ /^deparse(,.+)?$/) {
	    $deparse = 1;
	    $deparse_opts = $1;
	}
	splice(@ARGV, $idx, 1);
    }
}

chdir 't' if -f 't/TEST';

die "You need to run \"make test\" first to set things up.\n"
  unless -e 'perl' or -e 'perl.exe';

if ($ENV{PERL_3LOG}) {
    unless (-x 'perl.third') {
	unless (-x '../perl.third') {
	    die "You need to run \"make perl.third first.\n";
	}
	else {
	    print "Symlinking ../perl.third as perl.third...\n";
	    die "Failed to symlink: $!\n"
		unless symlink("../perl.third", "perl.third");
	    die "Symlinked but no executable perl.third: $!\n"
		unless -x 'perl.third';
	}
    }
}

# check leakage for embedders
$ENV{PERL_DESTRUCT_LEVEL} = 2 unless exists $ENV{PERL_DESTRUCT_LEVEL};

$ENV{EMXSHELL} = 'sh';        # For OS/2


# Roll your own File::Find!
use TestInit;
use File::Spec;
my $curdir = File::Spec->curdir;
my $updir  = File::Spec->updir;

sub _find_tests {
    my($dir) = @_;
    opendir DIR, $dir || die "Trouble opening $dir: $!";
    foreach my $f (readdir DIR) {
        next if $f eq $curdir or $f eq $updir;

        my $fullpath = File::Spec->catdir($dir, $f);

        _find_tests($fullpath) if -d $fullpath;
        push @ARGV, $fullpath if $f =~ /\.t$/;
    }
}

unless (@ARGV) {
    foreach my $dir (qw(base comp cmd run io op pragma lib pod)) {
        _find_tests($dir);
    }
}

# %infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );
%infinite = ();

if ($deparse) {
    _testprogs('deparse', @ARGV);
} else {
    _testprogs('perl', @ARGV);
    _testprogs('compile', @ARGV) if (-e "../testcompile");
}

sub _testprogs {
    $type = shift @_;
    @tests = @_;


    print <<'EOT' if ($type eq 'compile');
--------------------------------------------------------------------------------
TESTING COMPILER
--------------------------------------------------------------------------------
EOT

    print <<'EOT' if ($type eq 'deparse');
--------------------------------------------------------------------------------
TESTING DEPARSER
--------------------------------------------------------------------------------
EOT

    $ENV{PERLCC_TIMEOUT} = 120
          if ($type eq 'compile' && !$ENV{PERLCC_TIMEOUT});

    $bad = 0;
    $good = 0;
    $total = @tests;
    $files  = 0;
    $totmax = 0;
    $maxlen = 0;
    foreach (@tests) {
	$len = length;
	$maxlen = $len if $len > $maxlen;
    }
    # +3 : we want three dots between the test name and the "ok"
    # -2 : the .t suffix
    $dotdotdot = $maxlen + 3 - 2;
    while ($test = shift @tests) {

	if ( $infinite{$test} && $type eq 'compile' ) {
	    print STDERR "$test creates infinite loop! Skipping.\n";
            next;
	}
	if ($test =~ /^$/) {
	    next;
	}
	if ($type eq 'deparse') {
	    if ($test eq "comp/redef.t") {
		# Redefinition happens at compile time
		next;
	    }
	    elsif ($test eq "lib/switch.t") {
		# B::Deparse doesn't support source filtering
		next;
	    }
	}
	$te = $test;
	chop($te);
	print "$te" . '.' x ($dotdotdot - length($te));

	open(SCRIPT,"<$test") or die "Can't run $test.\n";
	$_ = <SCRIPT>;
	close(SCRIPT) unless ($type eq 'deparse');
	if (/#!.*perl(.*)$/) {
	    $switch = $1;
	    if ($^O eq 'VMS') {
		# Must protect uppercase switches with "" on command line
		$switch =~ s/-([A-Z]\S*)/"-$1"/g;
	    }
	}
	else {
	    $switch = '';
	}

	my $file_opts = "";
	if ($type eq 'deparse') {
	    # Look for #line directives which change the filename
	    while (<SCRIPT>) {
		$file_opts .= ",-f$3$4"
			if /^#\s*line\s+(\d+)\s+((\w+)|"([^"]+)")/;
	    }
	    close(SCRIPT);
	}
	my $utf = $with_utf ? '-I../lib -Mutf8'
	                    : '';
	my $testswitch = '-I. -MTestInit'; # -T will strict . from @INC
	if ($type eq 'deparse') {
	    my $deparse =
		"./perl $testswitch $switch -I../lib -MO=-qq,Deparse,".
		"-l$deparse_opts$file_opts ".
		"./$test > ./$test.dp ".
		"&& ./perl $testswitch $switch -I../lib ./$test.dp |";
	    open(RESULTS, $deparse)
		or print "can't deparse '$deparse': $!.\n";
	}
	elsif ($type eq 'perl') {
	    my $run = "./perl $testswitch $switch $utf $test |";
	    open(RESULTS,$run) or print "can't run '$run': $!.\n";
	}
	else {
	    my $compile =
		"./perl $testswitch -I../lib ../utils/perlcc -o ".
                "./$test.plc $utf ./$test ".
		" && ./$test.plc |";
	    open(RESULTS, $compile)
		or print "can't compile '$compile': $!.\n";
	    unlink "./$test.plc";
	}

	$ok = 0;
	$next = 0;
	while (<RESULTS>) {
	    if ($verbose) {
		print $_;
	    }
	    unless (/^#/) {
		if (/^1\.\.([0-9]+)/) {
		    $max = $1;
		    $totmax += $max;
		    $files += 1;
		    $next = 1;
		    $ok = 1;
		}
		else {
		    if (/^(not )?ok (\d+)(\s*#.*)?/ &&
			$2 == $next)
		    {
			my($not, $num, $extra) = ($1, $2, $3);
			my($istodo) = $extra =~ /^\s*#\s*TODO/ if $extra;

			if( $not && !$istodo ) {
			    $ok = 0;
			    $next = $num;
			    last;
			}
			else {
			    $next = $next + 1;
			}
                    }
                    elsif (/^Bail out!\s*(.*)/i) { # magic words
                        die "FAILED--Further testing stopped" . ($1 ? ": $1\n" : ".\n");
		    }
		    else {
			$ok = 0;
		    }
		}
	    }
	}
	close RESULTS;
	if ($type eq 'deparse') {
	    unlink "./$test.dp";
	}
	if ($ENV{PERL_3LOG}) {
	    my $tpp = $test;
	    $tpp =~ s:/:_:g;
	    $tpp =~ s:\.t$::;
	    rename("perl.3log", "perl.3log.$tpp");
	}
	$next = $next - 1;
	if ($ok && $next == $max) {
	    if ($max) {
		print "ok\n";
		$good = $good + 1;
	    }
	    else {
		print "skipping test on this platform\n";
		$files -= 1;
	    }
	}
	else {
	    $next += 1;
	    print "FAILED at test $next\n";
	    $bad = $bad + 1;
	    $_ = $test;
	    if (/^base/) {
		die "Failed a basic test--cannot continue.\n";
	    }
	}
    }

    if ($bad == 0) {
	if ($ok) {
	    print "All tests successful.\n";
	    # XXX add mention of 'perlbug -ok' ?
	}
	else {
	    die "FAILED--no tests were run for some reason.\n";
	}
    }
    else {
	$pct = $files ? sprintf("%.2f", ($files - $bad) / $files * 100) : "0.00";
	if ($bad == 1) {
	    warn "Failed 1 test script out of $files, $pct% okay.\n";
	}
	else {
	    warn "Failed $bad test scripts out of $files, $pct% okay.\n";
	}
	warn <<'SHRDLU';
   ### Since not all tests were successful, you may want to run some
   ### of them individually and examine any diagnostic messages they
   ### produce.  See the INSTALL document's section on "make test".
   ### If you are testing the compiler, then ignore this message
   ### and run
   ###      ./perl harness
   ### in the directory ./t.
SHRDLU
	warn <<'SHRDLU' if $good / $total > 0.8;
   ###
   ### Since most tests were successful, you have a good chance to
   ### get information with better granularity by running
   ###     ./perl harness
   ### in directory ./t.
SHRDLU
    }
    ($user,$sys,$cuser,$csys) = times;
    print sprintf("u=%g  s=%g  cu=%g  cs=%g  scripts=%d  tests=%d\n",
	$user,$sys,$cuser,$csys,$files,$totmax);
}
exit ($bad != 0);
