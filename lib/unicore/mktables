#!/usr/bin/perl -w
use strict;
use Carp;
##
## mktables -- create the runtime Perl Unicode files (lib/unicore/**/*.pl)
## from the Unicode database files (lib/unicore/*.txt).
##

mkdir("In", 0755);
mkdir("Is", 0755);
mkdir("To", 0755);

##
## Process any args.
##
my $Verbose = 0;

while (@ARGV)
{
    my $arg = shift @ARGV;
    if ($arg eq '-v') {
        $Verbose = 1;
    } elsif ($arg eq '-q') {
        $Verbose = 0;
    } else {
        die "usage: $0 [-v|-q]";
    }
}

my $LastUnicodeCodepoint = 0x10FFFF; # As of Unicode 3.1.1.

my $now = localtime;
my $HEADER=<<"EOF";
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
# This file is built by $0 from e.g. Unicode.txt.
# Any changes made here will be lost!
# Built $now.

EOF

##
## The main datastructure (a "Table") represents a set of code points that
## are part of a particular quality (that are part of \pL, \p{InGreek},
## etc.). They are kept as ranges of code points (starting and ending of
## each range).
##
## For example, a range ASCII LETTERS would be represented as:
##   [ [ 0x41 => 0x5A, 'UPPER' ],
##     [ 0x61 => 0x7A, 'LOWER, ] ]
##
sub RANGE_START() { 0 } ## index into range element
sub RANGE_END()   { 1 } ## index into range element
sub RANGE_NAME()  { 2 } ## index into range element

my %TableInfo;
my %FuzzyNames;
my %AliasInfo;

##
## Associates a property ("Greek", "Lu", "Assigned",...) with a Table.
##
## Called like:
##       New_Prop(In => 'Greek', $Table, AllowFuzzy => 1);
##
## Normally, these parameters are set when the Table is created (when the
## Table->New constructor is called), but there are times when it needs to
## be done after-the-fact...)
##
sub New_Prop($$$@)
{
    my $Type = shift; ## "Is" or "In";
    my $Name = shift;
    my $Table = shift;

    ## remaining args are optional key/val
    my %Args = @_;

    my $AllowFuzzy = delete $Args{AllowFuzzy};

    ## sanity check a few args
    if (%Args or ($Type ne 'Is' and $Type ne 'In') or not ref $Table) {
        confess "$0: bad args to New_Prop"
    }

    if (not $TableInfo{$Type}->{$Name})
    {
        $TableInfo{$Type}->{$Name} = $Table;
        if ($AllowFuzzy) {
            $FuzzyNames{$Type}->{$Name} = $Name;
        }
    }
}


##
## Creates a new Table object.
##
## Args are key/value pairs:
##    In => Name              -- Name of "In" property to be associated with
##    Is => Name              -- Name of "Is" property to be associated with
##    AllowFuzzy => Boolean   -- True if name can be accessed "fuzzily"
##
## No args are required.
##
sub Table::New
{
    my $class = shift;
    my %Args = @_;

    my $Table = bless [], $class;

    my $AllowFuzzy = delete $Args{AllowFuzzy};

    for my $Type ('Is', 'In')
    {
        if (my $Name = delete $Args{$Type}) {
            New_Prop($Type => $Name, $Table, AllowFuzzy => $AllowFuzzy);
        }
    }

    ## shouldn't have any left over
    if (%Args) {
        confess "$0: bad args to Table->New"
    }

    return $Table;
}

##
## Returns true if the Table has no code points
##
sub Table::IsEmpty
{
    my $Table = shift; #self
    return not @$Table;
}

##
## Returns true if the Table has code points
##
sub Table::NotEmpty
{
    my $Table = shift; #self
    return @$Table;
}

##
## Returns the maximum code point currently in the table.
##
sub Table::Max
{
    my $Table = shift; #self
    confess "oops" if $Table->IsEmpty; ## must have code points to have a max
    return $Table->[-1]->[RANGE_END];
}

##
## Replaces the codepoints in the Table with those in the Table given
## as an arg. (NOTE: this is not a "deep copy").
##
sub Table::Replace($$)
{
    my $Table = shift; #self
    my $New   = shift;

    @$Table = @$New;
}

##
## Given a new code point, make the last range of the Table extend to
## include the new (and all intervening) code points.
##
sub Table::Extend
{
    my $Table = shift; #self
    my $codepoint = shift;

    my $PrevMax = $Table->Max;

    confess "oops ($codepoint <= $PrevMax)" if $codepoint <= $PrevMax;

    $Table->[-1]->[RANGE_END] = $codepoint;
}

##
## Given a code point range start and end (and optional name), blindly
## append them to the list of ranges for the Table.
##
## NOTE: Code points must be added in strictly ascending numeric order.
##
sub Table::RawAppendRange
{
    my $Table = shift; #self
    my $start = shift;
    my $end   = shift;
    my $name  = shift;
    $name = "" if not defined $name; ## warning: $name can be "0"

    push @$Table, [ $start,    # RANGE_START
                    $end,      # RANGE_END
                    $name   ]; # RANGE_NAME
}

##
## Given a code point (and optional name), add it to the Table.
##
## NOTE: Code points must be added in strictly ascending numeric order.
##
sub Table::Append
{
    my $Table     = shift; #self
    my $codepoint = shift;
    my $name      = shift;
    $name = "" if not defined $name; ## warning: $name can be "0"

    ##
    ## If we've already got a range working, and this code point is the next
    ## one in line, and if the name is the same, just extend the current range.
    ##
    if ($Table->NotEmpty
        and
        $Table->Max == $codepoint - 1
        and
        $Table->[-1]->[RANGE_NAME] eq $name)
    {
        $Table->Extend($codepoint);
    }
    else
    {
        $Table->RawAppendRange($codepoint, $codepoint, $name);
    }
}

##
## Given a code point range starting value and ending value (and name),
## Add the range to teh Table.
##
## NOTE: Code points must be added in strictly ascending numeric order.
##
sub Table::AppendRange
{
    my $Table = shift; #self
    my $start = shift;
    my $end   = shift;
    my $name  = shift;
    $name = "" if not defined $name; ## warning: $name can be "0"

    $Table->Append($start, $name);
    $Table->Extend($end) if $end > $start;
}

##
## Return a new Table that represents all code points not in the Table.
##
sub Table::Invert
{
    my $Table = shift; #self

    my $New = Table->New();
    my $max = -1;
    for my $range (@$Table)
    {
        my $start = $range->[RANGE_START];
        my $end   = $range->[RANGE_END];
        if ($start-1 >= $max+1) {
            $New->AppendRange($max+1, $start-1, "");
        }
        $max = $end;
    }
    if ($max+1 < $LastUnicodeCodepoint) {
        $New->AppendRange($max+1, $LastUnicodeCodepoint);
    }
    return $New;
}

##
## Merges any number of other tables with $self, returning the new table.
## (existing tables are not modified)
##
## Can be called as either a constructor or a method.
##
sub Table::Merge
{
    shift(@_) if not ref $_[0]; ## if called as a constructor, lose the class
    my @Tables = @_;

    ## Accumulate all records from all tables
    my @Records;
    for my $Table (@Tables) {
        push @Records, @$Table;
    }

    ## sort by range start, with longer ranges coming first.
    my ($first, @Rest) = sort {
        ($a->[RANGE_START] <=> $b->[RANGE_START])
          or
        ($b->[RANGE_END]   <=> $b->[RANGE_END])
    } @Records;

    my $New = Table->New();

    ## Ensuring the first range is there makes the subsequent loop easier
    $New->AppendRange($first->[RANGE_START],
                      $first->[RANGE_END]);

    ## Fold in records so long as they add new information.
    for my $set (@Rest)
    {
        my $start = $set->[RANGE_START];
        my $end   = $set->[RANGE_END];
        if ($start > $New->Max) {
            $New->AppendRange($start, $end);
        } elsif ($end > $New->Max) {
            $New->Extend($end);
        }
    }

    return $New;
}

##
## Given a filename, write a representation of the Table to a file.
##
sub Table::Write
{
    my $Table = shift; #self
    my $filename = shift;

    print "$filename\n" if $Verbose;

    if (not open(OUT, ">$filename")) {
	die "$0: can't write $filename: $!\n";
    }

    print OUT $HEADER;
    print OUT "return <<'END';\n";

    for my $set (@$Table)
    {
        my $start = $set->[RANGE_START];
        my $end   = $set->[RANGE_END];
        my $name  = $set->[RANGE_NAME];

        if ($start == $end) {
            printf OUT "%04X\t\t%s\n", $start, $name;
        } else {
            printf OUT "%04X\t%04X\t%s\n", $start, $end, $name;
        }
    }

    print OUT "END\n";
    close OUT;
}

###########################################################################
###########################################################################
###########################################################################


##
## Called like:
##     New_Alias(Is => 'All', SameAs => 'Any', AllowFuzzy => 1);
##
## The args must be in that order, although the AllowFuzzy pair may be omitted.
##
## This creates 'IsAll' as an alias for 'IsAny'
##
sub New_Alias($$$@)
{
    my $Type   = shift; ## "Is" or "In"
    my $Alias  = shift;
    my $SameAs = shift;
    my $Name   = shift;

    ## remaining args are optional key/val
    my %Args = @_;

    my $AllowFuzzy = delete $Args{AllowFuzzy};

    ## sanity check a few args
    if (%Args or ($Type ne 'Is' and $Type ne 'In') or $SameAs ne 'SameAs') {
        confess "$0: bad args to New_Alias"
    }

    if (not $TableInfo{$Type}->{$Name}) {
        confess "$0: don't have orignial $Type => $Name to make alias"
    }
    if ($TableInfo{$Alias}) {
        confess "$0: already have original $Type => $Alias; can't make alias";
    }
    $AliasInfo{$Type}->{$Name} = $Alias;
    if ($AllowFuzzy) {
        $FuzzyNames{$Type}->{$Alias} = $Name;
    }

}

##
## Turn something like
##    OLD-ITALIC
## to
##    Old_Italic
##
sub CanonicalName($)
{
    my $name = lc shift;
    $name =~ s/\W+/_/;
    $name =~ s/(?<![a-z])(\w)/\u$1/g;
    return $name;
}


## All assigned code points
my $Assigned = Table->New(Is => 'Assigned', AllowFuzzy => 1);

my $Name     = Table->New(); ## all characters, individually by name
my $General  = Table->New(); ## all characters, grouped by category
my %General;
my %Cat;

##
## Process Unicode.txt (Categories, etc.)
##
sub Unicode_Txt()
{
    my $Bidi     = Table->New();
    my $Deco     = Table->New();
    my $Comb     = Table->New();
    my $Number   = Table->New();
    my $Mirrored = Table->New(Is => 'Mirrored', AllowFuzzy => 0);

    my %DC;
    my %Bidi;
    my %Deco;
    $Deco{Canon}   = Table->New(Is => 'Canon',  AllowFuzzy => 0);
    $Deco{Compat}  = Table->New(Is => 'Compat', AllowFuzzy => 0);

    ## Initialize Perl-generated categories
    $Cat{Alnum}     = Table->New(Is => 'Alnum',     AllowFuzzy => 0);
    $Cat{Alpha}     = Table->New(Is => 'Alpha',     AllowFuzzy => 0);
    $Cat{ASCII}     = Table->New(Is => 'ASCII',     AllowFuzzy => 0);
    $Cat{Blank}     = Table->New(Is => 'Blank',     AllowFuzzy => 0);
    $Cat{Cntrl}     = Table->New(Is => 'Cntrl',     AllowFuzzy => 0);
    $Cat{Digit}     = Table->New(Is => 'Digit',     AllowFuzzy => 0);
    $Cat{Graph}     = Table->New(Is => 'Graph',     AllowFuzzy => 0);
    $Cat{Lower}     = Table->New(Is => 'Lower',     AllowFuzzy => 0);
    $Cat{Print}     = Table->New(Is => 'Print',     AllowFuzzy => 0);
    $Cat{Punct}     = Table->New(Is => 'Punct',     AllowFuzzy => 0);
    $Cat{SpacePerl} = Table->New(Is => 'SpacePerl', AllowFuzzy => 0);
    $Cat{Space}     = Table->New(Is => 'Space',     AllowFuzzy => 0);
    $Cat{Title}     = Table->New(Is => 'Title',     AllowFuzzy => 0);
    $Cat{Upper}     = Table->New(Is => 'Upper',     AllowFuzzy => 0);
    $Cat{Word}      = Table->New(Is => 'Word' ,     AllowFuzzy => 0);
    $Cat{XDigit}    = Table->New(Is => 'XDigit',    AllowFuzzy => 0);
    ## Categories from Unicode.txt are auto-initialized in gencat()

    my %To;
    $To{Upper} = Table->New();
    $To{Lower} = Table->New();
    $To{Title} = Table->New();
    $To{Digit} = Table->New();

    sub gencat($$$$)
    {
        my ($name, ## Name ("LATIN CAPITAL LETTER A")
            $cat,  ## Category ("Lu", "Zp", "Nd", etc.)
            $code, ## Code point (as an integer)
            $op) = @_;

        my $MajorCat = substr($cat, 0, 1); ## L, M, Z, S, etc

        $Assigned->$op($code);
        $Name->$op($code, $name);
        $General->$op($code, $cat);

        ## add to the sub category (e.g. "Lu", "Nd", "Cf", ..)
        $Cat{$cat}      ||= Table->New(Is => $cat, AllowFuzzy => 0);
        $Cat{$cat}->$op($code);

        ## add to the major category (e.g. "L", "N", "C", ...)
        $Cat{$MajorCat} ||= Table->New(Is => $MajorCat, AllowFuzzy => 0);
        $Cat{$MajorCat}->$op($code);

        ($General{$name} ||= Table->New)->$op($code, $name);

        # 005F: SPACING UNDERSCORE
        $Cat{Word}->$op($code)  if $cat =~ /^[LMN]/ || $code == 0x005F;
        $Cat{Alnum}->$op($code) if $cat =~ /^[LMN]/;
        $Cat{Alpha}->$op($code) if $cat =~ /^[LM]/;



        $Cat{Space}->$op($code) if $cat  =~ /^Z/
                                || $code == 0x0009  # 0009: HORIZONTAL TAB
                                || $code == 0x000A  # 000A: LINE FEED
                                || $code == 0x000B  # 000B: VERTICAL TAB
                                || $code == 0x000C  # 000C: FORM FEED
                                || $code == 0x000D; # 000D: CARRIAGE RETURN


        $Cat{SpacePerl}->$op($code) if $cat =~ /^Z/
                                    || $code == 0x0009 # 0009: HORIZONTAL TAB
                                    || $code == 0x000A # 000A: LINE FEED
                                    || $code == 0x000C # 000C: FORM FEED
                                    || $code == 0x000D # 000D: CARRIAGE RETURN
                                    || $code == 0x0085 # 0085: <NEXT LINE>
                                    || $code == 0x2028 # 2028: LINE SEPARATOR
                                    || $code == 0x2029;# 2029: PARAGRAPH SEP.

        $Cat{Blank}->$op($code) if $cat  =~ /^Z[^lp]$/
                                || $code == 0x0009  # 0009: HORIZONTAL TAB
                                || $code == 0x0020; # 0020: SPACE

        $Cat{Digit}->$op($code) if $cat eq "Nd";
        $Cat{Upper}->$op($code) if $cat eq "Lu";
        $Cat{Lower}->$op($code) if $cat eq "Ll";
        $Cat{Title}->$op($code) if $cat eq "Lt";
        $Cat{ASCII}->$op($code) if $code <= 0x007F;
        $Cat{Cntrl}->$op($code) if $cat =~ /^C/;
        $Cat{Graph}->$op($code) if $cat =~ /^([LMNPS]|Co)/;
        $Cat{Print}->$op($code) if $cat =~ /^([LMNPS]|Co|Zs)/;
        $Cat{Punct}->$op($code) if $cat =~ /^P/;

        $Cat{XDigit}->$op($code) if ($code >= 0x30 && $code <= 0x39)  ## 0..9
                                 || ($code >= 0x41 && $code <= 0x46)  ## A..F
                                 || ($code >= 0x61 && $code <= 0x66); ## a..f
    }

    ## open ane read file.....
    if (not open IN, "Unicode.txt") {
        die "$0: Unicode.txt: $!\n";
    }

    while (<IN>)
    {
        next unless /^[0-9A-Fa-f]+;/;
        s/\s+$//;

        my ($hexcode,   ## code point in hex (e.g. "0041")
            $name,      ## character name (e.g. "LATIN CAPITAL LETTER A")
            $cat,       ## category (e.g. "Lu")
            $comb,      ## Canonical combining class (e.t. "230")
            $bidi,      ## directional category (e.g. "L")
            $deco,      ## decomposition mapping
            $decimal,   ## decimal digit value
            $digit,     ## digit value
            $number,    ## numeric value
            $mirrored,  ## mirrored
            $unicode10, ## name in Unicode 1.0
            $comment,   ## comment field
            $upper,     ## uppercase mapping
            $lower,     ## lowercase mapping
            $title,     ## titlecase mapping
              ) = split(/\s*;\s*/);

        my $code = hex($hexcode);

        ##
        ## There are a few pairs of lines like:
        ##   AC00;<Hangul Syllable, First>;Lo;0;L;;;;;N;;;;;
        ##   D7A3;<Hangul Syllable, Last>;Lo;0;L;;;;;N;;;;;
        ## that define ranges.
        ##
        if ($name =~ /^<(.+), (First|Last)>$/)
        {
            $name = $1;
            gencat($name, $cat, $code, $2 eq 'First' ? 'Append' : 'Extend');
            #New_Prop(In => $name, $General{$name}, AllowFuzzy => 1);
        }
        else
        {
            ## normal (single-character) lines
            gencat($name, $cat, $code, 'Append');

            # No Append() here since since several codes may map into one.
            $To{Upper}->RawAppendRange($code, $code, $upper) if $upper;
            $To{Lower}->RawAppendRange($code, $code, $lower) if $lower;
            $To{Title}->RawAppendRange($code, $code, $title) if $title;
            $To{Digit}->Append($code, $decimal) if length $decimal;

            $Bidi->Append($code, $bidi);
            $Comb->Append($code, $comb) if $comb;
            $Number->Append($code, $number) if length $number;

            $Mirrored->Append($code) if $mirrored eq "Y";

            $Bidi{$bidi} ||= Table->New(Is => "Bidi$bidi", AllowFuzzy => 0);
            $Bidi{$bidi}->Append($code);

            if ($deco)
            {
                $Deco->Append($code, $deco);
                if ($deco =~/^<(\w+)>/)
                {
                    $Deco{Compat}->Append($code);

                    $DC{$1} ||= Table->New(Is => "DC$1", AllowFuzzy => 0);
                    $DC{$1}->Append($code);
                }
                else
                {
                    $Deco{Canon}->Append($code);
                }
            }
        }
    }
    close IN;

    ##
    ## Tidy up a few special cases....
    ##

    $Cat{Cn} = $Assigned->Invert; ## Cn is everything that doesn't exist
    New_Prop(Is => 'Cn', $Cat{Cn}, AllowFuzzy => 0);

    ## Unassigned is the same as 'Cn'
    New_Alias(Is => 'Unassigned', SameAs => 'Cn', AllowFuzzy => 1);

    $Cat{C}->Replace($Cat{C}->Merge($Cat{Cn}));  ## Now merge in Cn into C


    # L& is Ll, Lu, and Lt.
    New_Prop(Is => 'L&',
             Table->Merge(@Cat{qw[Ll Lu Lt]}),
             AllowFuzzy => 0);

    ## Any and All are all code points.
    my $Any = Table->New(Is => 'Any', AllowFuzzy => 1);
    $Any->RawAppendRange(0, $LastUnicodeCodepoint);

    New_Alias(Is => 'All', SameAs => 'Any', AllowFuzzy => 1);


    ##
    ## Now dump the files.
    ##
    $Name->Write("Name.pl");
    $Bidi->Write("Bidirectional.pl");
    $Comb->Write("CombiningClass.pl");
    $Deco->Write("Decomposition.pl");
    $Number->Write("Number.pl");
    $General->Write("Category.pl");

    for my $to (sort keys %To) {
        $To{$to}->Write("To/$to.pl");
    }
}

##
## Process LineBrk.txt
##
sub LineBrk_Txt()
{
    if (not open IN, "LineBrk.txt") {
        die "$0: LineBrk.txt: $!\n";
    }

    my $Lbrk = Table->New();
    my %Lbrk;

    while (<IN>)
    {
        next unless /^([0-9A-Fa-f]+)(?:\.\.([0-9A-Fa-f]+))?\s*;\s*(\w+)/;

	my ($first, $last, $lbrk) = (hex($1), hex($2||""), $3);

	$Lbrk->Append($first, $lbrk);

        $Lbrk{$lbrk} ||= Table->New(Is => "Lbrk$lbrk", AllowFuzzy => 0);
        $Lbrk{$lbrk}->Append($first);

	if ($last) {
	    $Lbrk->Extend($last);
	    $Lbrk{$lbrk}->Extend($last);
	}
    }
    close IN;

    $Lbrk->Write("Lbrk.pl");
}

##
## Process ArabShap.txt.
##
sub ArabShap_txt()
{
    if (not open IN, "ArabShap.txt") {
        die "$0: ArabShap.txt: $!\n";
    }

    my $ArabLink      = Table->New();
    my $ArabLinkGroup = Table->New();

    while (<IN>)
    {
	next unless /^[0-9A-Fa-f]+;/;
	s/\s+$//;

	my ($hexcode, $name, $link, $linkgroup) = split(/\s*;\s*/);
        my $code = hex($hexcode);
	$ArabLink->Append($code, $link);
	$ArabLinkGroup->Append($code, $linkgroup);
    }
    close IN;

    $ArabLink->Write("ArabLink.pl");
    $ArabLinkGroup->Write("ArabLnkGrp.pl");
}

##
## Process Jamo.txt.
##
sub Jamo_txt()
{
    if (not open IN, "Jamo.txt") {
        die "$0: Jamo.txt: $!\n";
    }
    my $Short = Table->New();

    while (<IN>)
    {
	next unless /^([0-9A-Fa-f]+)\s*;\s*(\w*)/;
	my ($code, $short) = (hex($1), $2);

	$Short->Append($code, $short);
    }
    close IN;
    $Short->Write("JamoShort.pl");
}

##
## Process Scripts.txt.
##
sub Scripts_txt()
{
    my @ScriptInfo;

    if (not open(IN, "Scripts.txt")) {
        die "$0: Scripts.txt: $!\n";
    }
    while (<IN>) {
        next unless /^([0-9A-Fa-f]+)(?:\.\.([0-9A-Fa-f]+))?\s*;\s*(.+?)\s*\#/;

        # Wait until all the scripts have been read since
        # they are not listed in numeric order.
        push @ScriptInfo, [ hex($1), hex($2||""), $3 ];
    }
    close IN;

    # Now append the scripts properties in their code point order.

    my %Script;
    my $Scripts = Table->New();

    for my $script (sort { $a->[0] <=> $b->[0] } @ScriptInfo)
    {
        my ($first, $last, $name) = @$script;
        $Scripts->Append($first, $name);

        $Script{$name} ||= Table->New(Is => CanonicalName($name),
                                      AllowFuzzy => 1);
        $Script{$name}->Append($first, $name);

        if ($last) {
            $Scripts->Extend($last);
            $Script{$name}->Extend($last);
        }
    }

    $Scripts->Write("Scripts.pl");

    ## Common is everything not explicitly assigned to a Script
    ##
    ##    ***shouldn't this be intersected with \p{Assigned}? ******
    ##
    New_Prop(Is => 'Common', $Scripts->Invert, AllowFuzzy => 1);
}

##
## Given a name like "Close Punctuation", return a regex (that when applied
## with /i) matches any valid form of that name (e.g. "ClosePunctuation",
## "Close-Punctuation", etc.)
##
## Accept any space, dash, or underbar where in the official name there is
## space or a dash (or underbar, but there never is).
##
##
sub NameToRegex($)
{
    my $Name = shift;
    $Name =~ s/[- _]/(?:[-_]|\\s+)?/g;
    return $Name;
}

##
## Process Blocks.txt.
##
sub Blocks_txt()
{
    my $Blocks = Table->New();
    my %Blocks;

    if (not open IN, "Blocks.txt") {
        die "$0: Blocks.txt: $!\n";
    }

    while (<IN>)
    {
        #next if not /Private Use$/;
	next if not /^([0-9A-Fa-f]+)\.\.([0-9A-Fa-f]+)\s*;\s*(.+?)\s*$/;

	my ($first, $last, $name) = (hex($1), hex($2), $3);

	$Blocks->Append($first, $name);

        $Blocks{$name} ||= Table->New(In=>CanonicalName($name), AllowFuzzy=>1);
        $Blocks{$name}->Append($first, $name);

	if ($last and $last != $first) {
	    $Blocks->Extend($last);
	    $Blocks{$name}->Extend($last);
	}
    }
    close IN;

    $Blocks->Write("Blocks.pl");
}

##
## Read in the PropList.txt.  It contains extended properties not
## listed in the Unicode.txt, such as 'Other_Alphabetic':
## alphabetic but not of the general category L; many modifiers
## belong to this extended property category: while they are not
## alphabets, they are alphabetic in nature.
##
sub PropList_txt()
{
    my @PropInfo;

    if (not open IN, "PropList.txt") {
        die "$0: PropList.txt: $!\n";
    }

    while (<IN>)
    {
	next unless /^([0-9A-Fa-f]+)(?:\.\.([0-9A-Fa-f]+))?\s*;\s*(.+?)\s*\#/;

	# Wait until all the extended properties have been read since
	# they are not listed in numeric order.
	push @PropInfo, [ hex($1), hex($2||""), $3 ];
    }
    close IN;

    # Now append the extended properties in their code point order.
    my $Props = Table->New();
    my %Prop;

    for my $prop (sort { $a->[0] <=> $b->[0] } @PropInfo)
    {
        my ($first, $last, $name) = @$prop;
        $Props->Append($first, $name);

        $Prop{$name} ||= Table->New(Is => $name, AllowFuzzy => 1);
        $Prop{$name}->Append($first, $name);

        if ($last) {
            $Props->Extend($last);
            $Prop{$name}->Extend($last);
        }
    }

    # Alphabetic is L and Other_Alphabetic.
    New_Prop(Is => 'Alphabetic',
             Table->Merge($Cat{L}, $Prop{Other_Alphabetic}),
             AllowFuzzy => 1);

    # Lowercase is Ll and Other_Lowercase.
    New_Prop(Is => 'Lowercase',
             Table->Merge($Cat{Ll}, $Prop{Other_Lowercase}),
             AllowFuzzy => 1);

    # Uppercase is Lu and Other_Uppercase.
    New_Prop(Is => 'Uppercase',
             Table->Merge($Cat{Lu}, $Prop{Other_Uppercase}),
             AllowFuzzy => 1);

    # Math is Sm and Other_Math.
    New_Prop(Is => 'Math',
             Table->Merge($Cat{Sm}, $Prop{Other_Math}),
             AllowFuzzy => 1);

    # ID_Start is Ll, Lu, Lt, Lm, Lo, and Nl.
    New_Prop(Is => 'ID_Start',
             Table->Merge(@Cat{qw[Ll Lu Lt Lm Lo Nl]}),
             AllowFuzzy => 1);

    # ID_Continue is ID_Start, Mn, Mc, Nd, and Pc.
    New_Prop(Is => 'ID_Continue',
             Table->Merge(@Cat{qw[Ll Lu Lt Lm Lo Nl Mn Mc Nd Pc ]}),
             AllowFuzzy => 1);
}

sub Make_GC_Aliases()
{
    ##
    ## The mapping from General Category long forms to short forms is
    ## currently hardwired here since no simple data file in the UCD
    ## seems to do that.  Unicode 3.2 will assumedly correct this.
    ##
    my %Is = (
	'Letter'			=>	'L',
	'Uppercase_Letter'		=>	'Lu',
	'Lowercase_Letter'		=>	'Ll',
	'Titlecase_Letter'		=>	'Lt',
	'Modifier_Letter'		=>	'Lm',
	'Other_Letter'			=>	'Lo',

	'Mark'				=>	'M',
	'Non_Spacing_Mark'		=>	'Mn',
	'Spacing_Mark'			=>	'Mc',
	'Enclosing_Mark'		=>	'Me',

	'Separator'			=>	'Z',
	'Space_Separator'		=>	'Zs',
	'Line_Separator'		=>	'Zl',
	'Paragraph_Separator'		=>	'Zp',

	'Number'			=>	'N',
	'Decimal_Number'		=>	'Nd',
	'Letter_Number'			=>	'Nl',
	'Other_Number'			=>	'No',

	'Punctuation'			=>	'P',
	'Connector_Punctuation'		=>	'Pc',
	'Dash_Punctuation'		=>	'Pd',
	'Open_Punctuation'		=>	'Ps',
	'Close_Punctuation'		=>	'Pe',
	'Initial_Punctuation'		=>	'Pi',
	'Final_Punctuation'		=>	'Pf',
	'Other_Punctuation'		=>	'Po',

	'Symbol'			=>	'S',
	'Math_Symbol'			=>	'Sm',
	'Currency_Symbol'		=>	'Sc',
	'Modifier_Symbol'		=>	'Sk',
	'Other_Symbol'			=>	'So',

	'Other'				=>	'C',
	'Control'			=>	'Cc',
	'Format'			=>	'Cf',
	'Surrogate'			=>	'Cs',
	'Private Use'			=>	'Co',
	'Unassigned'			=>	'Cn',
    );

    ## make the aliases....
    while (my ($Alias, $Name) = each %Is) {
        New_Alias(Is => $Alias, SameAs => $Name, AllowFuzzy => 1);
    }
}

##
## Writes the info accumulated in
##
##       %TableInfo;
##       %FuzzyNames;
##       %AliasInfo;
##
##
sub WriteAllMappings()
{
    for my $Type ('In', 'Is')
    {
        my %Filenames;
        my %NameToFile;

        my %Exact; ## will become %utf8::Is    or %utf8::In
        my %Pat;   ## will become %utf8::IsPat or %utf8::InPat

        ##
        ## First write all the files to the $Type/ directory
        ##
        while (my ($Name, $Table) = each %{$TableInfo{$Type}})
        {
            ## Need an 8.3 safe filename.
            my $filename = $Name;
            $filename =~ s/[_\W]+(\w*)/\u$1/g;
            substr($filename, 8) = '' if length($filename) > 8;

            ##
            ## Make sure the filename doesn't conflict with something we
            ## might have already written. If we have, say,
            ##     Greek_Extended1
            ##     Greek_Extended2
            ## they become
            ##     Greek_Ex
            ##     Greek_E2
            ##
            while (my $num = $Filenames{lc $filename}++)
            {
                $num++; ## so filenames with numbers start with '2', which
                        ## just looks more natural.
                substr($filename, -length($num)) = $num;
            }

            ##
            ## Okay, write the file...
            ##
            $Exact{$Name} = $filename;
            $Table->Write("$Type/$filename.pl");
        }

        ##
        ## Build %Pat
        ##
        while (my ($Fuzzy, $Real) = each %{$FuzzyNames{$Type}})
        {
            my $File = $Exact{$Real};

            if (not $File) {
                die "$0: oops [$Real]";
            }

            ## The prefix length of 2 is enough spread,
            ## and besides, we have 'Yi' as an In category.
            my $Prefix = lc(substr($Fuzzy, 0, 2));
            my $Regex = NameToRegex($Fuzzy);

            if ($Pat{$Prefix}->{$Regex}) {
                warn "WHOA, conflict with /$Regex/: $Pat{$Prefix}->{$Regex} vs $File\n";
            }

            $Pat{$Prefix}->{$Regex} = $File;
        }

        ##
        ## Since the fuzzy method will provide for a way to match $Fuzzy,
        ## there's no need for $Fuzzy to be in %Exact as well.
        ## This can't be done in the loop above because there could be
        ## multiple $Fuzzys pointing at the same $Real, and we don't want
        ## the first to delete the exact mapping out from under the second.
        ##
        for my $Fuzzy (keys %{$FuzzyNames{$Type}})
        {
            delete $Exact{$Fuzzy};
        }



        ##
        ## Now write In.pl / Is.pl
        ##
        if (not open OUT, ">$Type.pl") {
            die "$0: $Type.pl: $!\n";
        }
        print OUT $HEADER;
        print OUT "##\n";
        print OUT "## Data in this file used by ../utf8_heavy.pl\n";
        print OUT "##\n";
        print OUT "\n";
        print OUT "## Mapping from name to filename in ./$Type\n";
        print OUT "%utf8::$Type = (\n";
        for my $Name (sort keys %Exact)
        {
            my $File = $Exact{$Name};
            printf OUT "  %-41s => %s,\n", "'$Name'", "'$File'";
        }
        print OUT ");\n\n";

        print OUT "## Mappings from regex to filename in ./$Type/\n";
        print OUT "%utf8::${Type}Pat = (\n";
        for my $Prefix (sort keys %Pat)
        {
            print OUT " '$Prefix' => {\n";
            while (my ($Regex, $File) = each %{ $Pat{$Prefix} }) {
                print OUT "\t'$Regex' => '$File',\n";
            }
            print OUT " },\n";
        }
        print OUT ");\n";

        close(OUT);
    }
}

sub SpecCase_txt()
{
    #
    # Read in the special cases.
    #

    my %CaseInfo;

    if (not open IN, "SpecCase.txt") {
        die "$0: SpecCase.txt: $!\n";
    }
    while (<IN>) {
        next unless /^[0-9A-Fa-f]+;/;
        s/\#.*//;
        s/\s+$//;

        my ($code, $lower, $title, $upper, $condition) = split(/\s*;\s*/);

        if ($condition) { # not implemented yet
            print "# SKIPPING $_\n" if $Verbose;
            next;
        }

        # Wait until all the special cases have been read since
        # they are not listed in numeric order.
        my $ix = hex($code);
        push @{$CaseInfo{Lower}}, [ $ix, $code, $lower ];
        push @{$CaseInfo{Title}}, [ $ix, $code, $title ];
        push @{$CaseInfo{Upper}}, [ $ix, $code, $upper ];
    }
    close IN;

    # Now write out the special cases properties in their code point order.
    # Prepend them to the To/{Upper,Lower,Title}.pl.

    for my $case (qw(Lower Title Upper))
    {
        my $NormalCase = do "To/$case.pl" || die "$0: $@\n";
        if (not open OUT, ">To/$case.pl") {
            die "$0: To/$case.txt: $!";
        }

        print OUT $HEADER, "\n";
        print OUT "%utf8::ToSpec$case =\n(\n";

        for my $prop (sort { $a->[0] <=> $b->[0] } @{$CaseInfo{$case}}) {
            my ($ix, $code, $to) = @$prop;
            my $tostr =
              join "", map { sprintf "\\x{%s}", $_ } split ' ', $to;
            printf OUT qq['%04X' => "$tostr",\n], $ix;
        }
        print OUT ");\n\n";
        print OUT "return <<'END';\n";
        print OUT $NormalCase;
        print OUT "END\n";
        close OUT;
    }
}

#
# Read in the case foldings.
#
# We will do full case folding, C + F + I (see CaseFold.txt).
#
sub CaseFold_txt()
{
    if (not open IN, "CaseFold.txt") {
	die "$0: To/Fold.pl: $!\n";
    }

    my $Fold = Table->New();
    my %Fold;

    while (<IN>) {
	# Skip status 'S', simple case folding
	next unless /^([0-9A-Fa-f]+)\s*;\s*([CFI])\s*;\s*([0-9A-Fa-f]+(?: [0-9A-Fa-f]+)*)\s*;/;

	my ($code, $status, $fold) = (hex($1), $2, $3);

	if ($status eq 'C') { # Common: one-to-one folding
	    # No append() since several codes may fold into one.
	    $Fold->RawAppendRange($code, $code, $fold);
	} else { # F: full, or I: dotted uppercase I -> dotless lowercase I
	    $Fold{$code} = $fold;
	}
    }
    close IN;

    $Fold->Write("To/Fold.pl");

    #
    # Prepend the special foldings to the common foldings.
    #

    my $CommonFold = do "To/Fold.pl" || die "$0: To/Fold.pl: $!\n";
    if (not open OUT, ">To/Fold.pl") {
        die "$0: To/Fold.pl: $!\n";
    }
    print OUT $HEADER, "\n";
    print OUT "%utf8::ToSpecFold =\n(\n";
    for my $code (sort { $a <=> $b } keys %Fold) {
        my $foldstr =
          join "", map { sprintf "\\x{%s}", $_ } split ' ', $Fold{$code};
        printf OUT qq['%04X' => "$foldstr",\n], $code;
    }
    print OUT ");\n\n";
    print OUT "return <<'END';\n";
    print OUT $CommonFold;
    print OUT "END\n";
    close OUT;
}

## Do it....

Unicode_Txt();
Make_GC_Aliases();
PropList_txt();

Scripts_txt();
Blocks_txt();

LineBrk_Txt();
ArabShap_txt();
Jamo_txt();
SpecCase_txt();

WriteAllMappings();

CaseFold_txt();

# That's all, folks!

__END__
