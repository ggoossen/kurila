#!/usr/bin/perl -w

#
# Database of global and static function prototypes.  This is used
# to generate prototype headers under various configurations,
# export symbols lists for different platforms, and macros to
# provide an implicit interpreter context argument.
#
use strict;

sub read_table (\%) {
    my $functions = shift;
    while (<DATA>) {
	next if /^\s*(#|$)/;
	chomp;
	while (s|\\$||) {
	    $_ .= <DATA>;
	    chomp;
	}
	my $cond;
	if (s/^c\s*\[([^\]]+)\]\s*//) {
	    $cond = $1;
	}
	my($flags,$retval,$func,@args) = split /\s*\|\s*/, $_;
	warn "dup $func\n" if exists $functions->{$func};
	$functions->{$func}{retval} = $retval;
	$functions->{$func}{args} = \@args;
	$functions->{$func}{conditional} = $cond if $cond;
	if ($flags =~ s|s\[([^\]]+)\]\s*|| && $1) {
	    $functions->{$func}{static} = $1;
	}
	$functions->{$func}{flags} = $flags;
    }
}

# generate proto.h
sub write_protos ($\%) {
    my $file = shift;
    my $functions = shift;
    local *F;
    open F, ">$file" or die "Can't open $file: $!";
    my @globals = sort grep { !exists $functions->{$_}{static} } keys %$functions;
    my @statics = sort grep { exists $functions->{$_}{static} } keys %$functions;
    for my $func (@globals, @statics) {
	my $fentry = $functions->{$func};
	my $cond = $fentry->{conditional} || "";
	my $flags = $fentry->{flags} || "";
	my $retval = $fentry->{retval} || "";
	my $args = $fentry->{args} || "";
	my $static = $fentry->{static} || "";
	if ($static) {
	    $cond .= " && " if $cond;
	    $cond .= "defined(PERL_IN_\U$static\E_C)";
	    $retval = "STATIC $retval";
	}
	print F "#if $cond\n" if $cond;
	$func = "Perl_$func" if $flags =~ /p/;
	my $context = "";
	unless ($flags =~ /n/) {
	    $context = "pTHX";
	    $context .= "_ " if @$args;
	}
	print F "$retval\t$func($context";
	if (@$args) {
	    print F join(", ", @$args);
	}
	else {
	    print F "void" if $flags =~ /n/;
	}
	print F ")";
	print F " __attribute__((noreturn))" if $flags =~ /r/;
	print F ";\n";
	print F "#endif\n" if $cond;
    }
    close F;
}

sub munge_c_files (\%) {
    my $functions = shift;
    unless (@ARGV) {
        warn "\@ARGV empty, nothing to do\n";
	return;
    }
    local $^I = '.bak';
    while (<>) {
	if (/^#\s*include\s+"perl.h"/) {
	    my $file = uc $ARGV;
	    $file =~ s/\./_/g;
	    print "#define PERL_IN_$file\n";
	}
	s{^(\w+)\s*\(}
	 {
	    my $f = $1;
	    my $repl = "$f(";
	    if (exists $functions->{$f}) {
		my $flags = $functions->{$f}{flags};
		$repl = "Perl_$repl" if $flags =~ /p/;
		unless ($flags =~ /n/) {
		    $repl .= "pTHX";
		    $repl .= "_ " if @{$functions->{$f}{args}};
		}
		warn("$ARGV:$.:$repl\n");
	    }
	    $repl;
	 }e;
	print;
	close ARGV if eof;	# restart $.
    }
}

sub write_global_sym ($\%) {
    my $file = shift;
    my $functions = shift;
    local *F;
    open F, ">$file" or die "Can't open $file: $!";
    print F <<'EOT';
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
# This file is autogenerated from data in proto.pl.  Edit that file
# and run 'make regen_headers' to effect changes.
#
EOT
    my @globals = sort grep { !exists $functions->{$_}{static} }
			keys %$functions;
    for my $func (@globals) {
	my $fentry = $functions->{$func};
	my $flags = $fentry->{flags} || "";
	$func = "Perl_$func" if $flags =~ /p/;
	print F "$func\n";
    }
    close F;
}

my %functions;
read_table(%functions);
sub get_table { \%functions }

write_protos('proto.h', %functions);
write_global_sym('global.sym', %functions);
#munge_c_files(%functions);

__END__

# New function prototypes must be added at the end of this file to
# maintain binary compatibility in some configurations

# Lines are of the form:
#    flags|return_type|function_name|return_type|arg1|arg2|...|argN
#
# Lines may continue on multiple lines when \w| begins the next line.
# Leading and trailing whitespace will be ignored in each component.
#
# flags are single letters with following meanings:
#	c[CONDITION]	function available #if CONDITION (must come first)
#	s[foo]		static, local to foo.c (everything else is global)
#	n		function has no implicit interpreter context argument
#	p		function has a Perl_ prefix
#	r		function never returns
# Individual flags may be separated by whitespace.
#

p	|SV*	|amagic_call	|SV* left|SV* right|int method|int dir
p	|bool	|Gv_AMupdate	|HV* stash
p	|OP*	|append_elem	|I32 optype|OP* head|OP* tail
p	|OP*	|append_list	|I32 optype|LISTOP* first|LISTOP* last
p	|I32	|apply		|I32 type|SV** mark|SV** sp
p	|void	|assertref	|OP* o
p	|bool	|avhv_exists_ent|AV *ar|SV* keysv|U32 hash
p	|SV**	|avhv_fetch_ent	|AV *ar|SV* keysv|I32 lval|U32 hash
p	|HE*	|avhv_iternext	|AV *ar
p	|SV*	|avhv_iterval	|AV *ar|HE* entry
p	|HV*	|avhv_keys	|AV *ar
p	|void	|av_clear	|AV* ar
p	|void	|av_extend	|AV* ar|I32 key
p	|AV*	|av_fake	|I32 size|SV** svp
p	|SV**	|av_fetch	|AV* ar|I32 key|I32 lval
p	|void	|av_fill	|AV* ar|I32 fill
p	|I32	|av_len		|AV* ar
p	|AV*	|av_make	|I32 size|SV** svp
p	|SV*	|av_pop		|AV* ar
p	|void	|av_push	|AV* ar|SV* val
p	|void	|av_reify	|AV* ar
p	|SV*	|av_shift	|AV* ar
p	|SV**	|av_store	|AV* ar|I32 key|SV* val
p	|void	|av_undef	|AV* ar
p	|void	|av_unshift	|AV* ar|I32 num
p	|OP*	|bind_match	|I32 type|OP* left|OP* pat
p	|OP*	|block_end	|I32 floor|OP* seq
p	|I32	|block_gimme
p	|int	|block_start	|int full
p	|void	|boot_core_UNIVERSAL
p	|void	|call_list	|I32 oldscope|AV* av_list
p	|I32	|cando		|I32 bit|I32 effective|Stat_t* statbufp
p	|U32	|cast_ulong	|double f
p	|I32	|cast_i32	|double f
p	|IV	|cast_iv	|double f
p	|UV	|cast_uv	|double f
c[!defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)] \
p	|I32	|my_chsize	|int fd|Off_t length
c[defined(USE_THREADS)] \
p	|MAGIC*	|condpair_magic	|SV *sv
p	|OP*	|convert	|I32 optype|I32 flags|OP* o
pr	|void	|croak		|const char* pat|...
p	|void	|cv_ckproto	|CV* cv|GV* gv|char* p
p	|CV*	|cv_clone	|CV* proto
p	|SV*	|cv_const_sv	|CV* cv
p	|SV*	|op_const_sv	|OP* o|CV* cv
p	|void	|cv_undef	|CV* cv
p	|void	|cx_dump	|PERL_CONTEXT* cs
p	|SV*	|filter_add	|filter_t funcp|SV* datasv
p	|void	|filter_del	|filter_t funcp
p	|I32	|filter_read	|int idx|SV* buffer|int maxlen
p	|char**	|get_op_descs
p	|char**	|get_op_names
p	|char*	|get_no_modify
p	|U32*	|get_opargs
p	|I32	|cxinc
p	|void	|deb		|const char* pat|...
p	|void	|deb_growlevel
p	|void	|debprofdump
p	|I32	|debop		|OP* o
p	|I32	|debstack
p	|I32	|debstackptrs
p	|char*	|delimcpy	|char* to|char* toend|char* from \
				|char* fromend|int delim|I32* retlen
p	|void	|deprecate	|char* s
p	|OP*	|die		|const char* pat|...
p	|OP*	|die_where	|char* message|STRLEN msglen
p	|void	|dounwind	|I32 cxix
p	|bool	|do_aexec	|SV* really|SV** mark|SV** sp
p	|int	|do_binmode	|PerlIO *fp|int iotype|int flag
p	|void	|do_chop	|SV* asv|SV* sv
p	|bool	|do_close	|GV* gv|bool not_implicit
p	|bool	|do_eof		|GV* gv
p	|bool	|do_exec	|char* cmd
c[!defined(WIN32)] \
p	|bool	|do_exec3	|char* cmd|int fd|int flag
p	|void	|do_execfree
c[defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)] \
p	|I32	|do_ipcctl	|I32 optype|SV** mark|SV** sp
c[defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)] \
p	|I32	|do_ipcget	|I32 optype|SV** mark|SV** sp
p	|void	|do_join	|SV* sv|SV* del|SV** mark|SV** sp
p	|OP*	|do_kv	|ARGSproto
c[defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)] \
p	|I32	|do_msgrcv	|SV** mark|SV** sp
c[defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)] \
p	|I32	|do_msgsnd	|SV** mark|SV** sp
p	|bool	|do_open	|GV* gv|char* name|I32 len|int as_raw \
				|int rawmode|int rawperm|PerlIO* supplied_fp
p	|void	|do_pipe	|SV* sv|GV* rgv|GV* wgv
p	|bool	|do_print	|SV* sv|PerlIO* fp
p	|OP*	|do_readline
p	|I32	|do_chomp	|SV* sv
p	|bool	|do_seek	|GV* gv|Off_t pos|int whence
c[defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)] \
p	|I32	|do_semop	|SV** mark|SV** sp
c[defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)] \
p	|I32	|do_shmio	|I32 optype|SV** mark|SV** sp
p	|void	|do_sprintf	|SV* sv|I32 len|SV** sarg
p	|Off_t	|do_sysseek	|GV* gv|Off_t pos|int whence
p	|Off_t	|do_tell	|GV* gv
p	|I32	|do_trans	|SV* sv
p	|void	|do_vecset	|SV* sv
p	|void	|do_vop		|I32 optype|SV* sv|SV* left|SV* right
p	|OP*	|dofile		|OP* term
p	|I32	|dowantarray
p	|void	|dump_all
p	|void	|dump_eval
c[defined(DUMP_FDS)] \
p	|void	|dump_fds	|char* s
p	|void	|dump_form	|GV* gv
p	|void	|gv_dump	|GV* gv
p	|void	|op_dump	|OP* arg
p	|void	|pmop_dump	|PMOP* pm
p	|void	|dump_packsubs	|HV* stash
p	|void	|dump_sub	|GV* gv
p	|void	|fbm_compile	|SV* sv|U32 flags
p	|char*	|fbm_instr	|unsigned char* big|unsigned char* bigend \
				|SV* littlesv|U32 flags
p	|char*	|find_script	|char *scriptname|bool dosearch \
				|char **search_ext|I32 flags
c[defined(USE_THREADS)] \
p	|PADOFFSET|find_threadsv|const char *name
p	|OP*	|force_list	|OP* arg
p	|OP*	|fold_constants	|OP* arg
p	|char*	|form		|const char* pat|...
p	|void	|free_tmps
p	|OP*	|gen_constant_list|OP* o
c[!defined(HAS_GETENV_LEN)] \
p	|char*	|getenv_len	|char* key|unsigned long *len
p	|void	|gp_free	|GV* gv
p	|GP*	|gp_ref		|GP* gp
p	|GV*	|gv_AVadd	|GV* gv
p	|GV*	|gv_HVadd	|GV* gv
p	|GV*	|gv_IOadd	|GV* gv
p	|GV*	|gv_autoload4	|HV* stash|const char* name|STRLEN len \
				|I32 method
p	|void	|gv_check	|HV* stash
p	|void	|gv_efullname	|SV* sv|GV* gv
p	|void	|gv_efullname3	|SV* sv|GV* gv|const char* prefix
p	|GV*	|gv_fetchfile	|const char* name
p	|GV*	|gv_fetchmeth	|HV* stash|const char* name|STRLEN len \
				|I32 level
p	|GV*	|gv_fetchmethod	|HV* stash|const char* name
p	|GV*	|gv_fetchmethod_autoload|HV* stash|const char* name \
				|I32 autoload
p	|GV*	|gv_fetchpv	|const char* name|I32 add|I32 sv_type
p	|void	|gv_fullname	|SV* sv|GV* gv
p	|void	|gv_fullname3	|SV* sv|GV* gv|const char* prefix
p	|void	|gv_init	|GV* gv|HV* stash|const char* name \
				|STRLEN len|int multi
p	|HV*	|gv_stashpv	|const char* name|I32 create
p	|HV*	|gv_stashpvn	|const char* name|U32 namelen|I32 create
p	|HV*	|gv_stashsv	|SV* sv|I32 create
p	|void	|hv_clear	|HV* tb
p	|void	|hv_delayfree_ent|HV* hv|HE* entry
p	|SV*	|hv_delete	|HV* tb|const char* key|U32 klen|I32 flags
p	|SV*	|hv_delete_ent	|HV* tb|SV* key|I32 flags|U32 hash
p	|bool	|hv_exists	|HV* tb|const char* key|U32 klen
p	|bool	|hv_exists_ent	|HV* tb|SV* key|U32 hash
p	|SV**	|hv_fetch	|HV* tb|const char* key|U32 klen|I32 lval
p	|HE*	|hv_fetch_ent	|HV* tb|SV* key|I32 lval|U32 hash
p	|void	|hv_free_ent	|HV* hv|HE* entry
p	|I32	|hv_iterinit	|HV* tb
p	|char*	|hv_iterkey	|HE* entry|I32* retlen
p	|SV*	|hv_iterkeysv	|HE* entry
p	|HE*	|hv_iternext	|HV* tb
p	|SV*	|hv_iternextsv	|HV* hv|char** key|I32* retlen
p	|SV*	|hv_iterval	|HV* tb|HE* entry
p	|void	|hv_ksplit	|HV* hv|IV newmax
p	|void	|hv_magic	|HV* hv|GV* gv|int how
p	|SV**	|hv_store	|HV* tb|const char* key|U32 klen|SV* val \
				|U32 hash
p	|HE*	|hv_store_ent	|HV* tb|SV* key|SV* val|U32 hash
p	|void	|hv_undef	|HV* tb
p	|I32	|ibcmp		|const char* a|const char* b|I32 len
p	|I32	|ibcmp_locale	|const char* a|const char* b|I32 len
p	|I32	|ingroup	|I32 testgid|I32 effective
p	|void	|init_stacks	|ARGSproto
p	|U32	|intro_my
p	|char*	|instr		|const char* big|const char* little
p	|bool	|io_close	|IO* io
p	|OP*	|invert		|OP* cmd
p	|bool	|is_uni_alnum	|U32 c
p	|bool	|is_uni_idfirst	|U32 c
p	|bool	|is_uni_alpha	|U32 c
p	|bool	|is_uni_space	|U32 c
p	|bool	|is_uni_digit	|U32 c
p	|bool	|is_uni_upper	|U32 c
p	|bool	|is_uni_lower	|U32 c
p	|bool	|is_uni_print	|U32 c
p	|U32	|to_uni_upper	|U32 c
p	|U32	|to_uni_title	|U32 c
p	|U32	|to_uni_lower	|U32 c
p	|bool	|is_uni_alnum_lc|U32 c
p	|bool	|is_uni_idfirst_lc|U32 c
p	|bool	|is_uni_alpha_lc|U32 c
p	|bool	|is_uni_space_lc|U32 c
p	|bool	|is_uni_digit_lc|U32 c
p	|bool	|is_uni_upper_lc|U32 c
p	|bool	|is_uni_lower_lc|U32 c
p	|bool	|is_uni_print_lc|U32 c
p	|U32	|to_uni_upper_lc|U32 c
p	|U32	|to_uni_title_lc|U32 c
p	|U32	|to_uni_lower_lc|U32 c
p	|bool	|is_utf8_alnum	|U8 *p
p	|bool	|is_utf8_idfirst|U8 *p
p	|bool	|is_utf8_alpha	|U8 *p
p	|bool	|is_utf8_space	|U8 *p
p	|bool	|is_utf8_digit	|U8 *p
p	|bool	|is_utf8_upper	|U8 *p
p	|bool	|is_utf8_lower	|U8 *p
p	|bool	|is_utf8_print	|U8 *p
p	|bool	|is_utf8_mark	|U8 *p
p	|OP*	|jmaybe		|OP* arg
p	|I32	|keyword	|char* d|I32 len
p	|void	|leave_scope	|I32 base
p	|void	|lex_end
p	|void	|lex_start	|SV* line
p	|OP*	|linklist	|OP* o
p	|OP*	|list		|OP* o
p	|OP*	|listkids	|OP* o
p	|OP*	|localize	|OP* arg|I32 lexical
p	|I32	|looks_like_number|SV* sv
p	|int	|magic_clearenv	|SV* sv|MAGIC* mg
p	|int	|magic_clear_all_env|SV* sv|MAGIC* mg
p	|int	|magic_clearpack|SV* sv|MAGIC* mg
p	|int	|magic_clearsig	|SV* sv|MAGIC* mg
p	|int	|magic_existspack|SV* sv|MAGIC* mg
p	|int	|magic_freeregexp|SV* sv|MAGIC* mg
p	|int	|magic_get	|SV* sv|MAGIC* mg
p	|int	|magic_getarylen|SV* sv|MAGIC* mg
p	|int	|magic_getdefelem|SV* sv|MAGIC* mg
p	|int	|magic_getglob	|SV* sv|MAGIC* mg
p	|int	|magic_getnkeys	|SV* sv|MAGIC* mg
p	|int	|magic_getpack	|SV* sv|MAGIC* mg
p	|int	|magic_getpos	|SV* sv|MAGIC* mg
p	|int	|magic_getsig	|SV* sv|MAGIC* mg
p	|int	|magic_getsubstr|SV* sv|MAGIC* mg
p	|int	|magic_gettaint	|SV* sv|MAGIC* mg
p	|int	|magic_getuvar	|SV* sv|MAGIC* mg
p	|int	|magic_getvec	|SV* sv|MAGIC* mg
p	|U32	|magic_len	|SV* sv|MAGIC* mg
c[defined(USE_THREADS)] \
p	|int	|magic_mutexfree|SV* sv|MAGIC* mg
p	|int	|magic_nextpack	|SV* sv|MAGIC* mg|SV* key
p	|U32	|magic_regdata_cnt|SV* sv|MAGIC* mg
p	|int	|magic_regdatum_get|SV* sv|MAGIC* mg
p	|int	|magic_set	|SV* sv|MAGIC* mg
p	|int	|magic_setamagic|SV* sv|MAGIC* mg
p	|int	|magic_setarylen|SV* sv|MAGIC* mg
p	|int	|magic_setbm	|SV* sv|MAGIC* mg
p	|int	|magic_setdbline|SV* sv|MAGIC* mg
c[defined(USE_LOCALE_COLLATE)] \
p	|int	|magic_setcollxfrm|SV* sv|MAGIC* mg
p	|int	|magic_setdefelem|SV* sv|MAGIC* mg
p	|int	|magic_setenv	|SV* sv|MAGIC* mg
p	|int	|magic_setfm	|SV* sv|MAGIC* mg
p	|int	|magic_setisa	|SV* sv|MAGIC* mg
p	|int	|magic_setglob	|SV* sv|MAGIC* mg
p	|int	|magic_setmglob	|SV* sv|MAGIC* mg
p	|int	|magic_setnkeys	|SV* sv|MAGIC* mg
p	|int	|magic_setpack	|SV* sv|MAGIC* mg
p	|int	|magic_setpos	|SV* sv|MAGIC* mg
p	|int	|magic_setsig	|SV* sv|MAGIC* mg
p	|int	|magic_setsubstr|SV* sv|MAGIC* mg
p	|int	|magic_settaint	|SV* sv|MAGIC* mg
p	|int	|magic_setuvar	|SV* sv|MAGIC* mg
p	|int	|magic_setvec	|SV* sv|MAGIC* mg
p	|int	|magic_set_all_env|SV* sv|MAGIC* mg
p	|U32	|magic_sizepack	|SV* sv|MAGIC* mg
p	|int	|magic_wipepack	|SV* sv|MAGIC* mg
p	|void	|magicname	|char* sym|char* name|I32 namlen
n	|int	|main		|int argc|char** argv|char** env
c[defined(MYMALLOC)] \
p	|MEM_SIZE|malloced_size	|void *p
p	|void	|markstack_grow
c[defined(USE_LOCALE_COLLATE)] \
p	|char*	|mem_collxfrm	|const char* s|STRLEN len|STRLEN* xlen
p	|SV*	|mess		|const char* pat|va_list* args
p	|int	|mg_clear	|SV* sv
p	|int	|mg_copy	|SV* sv|SV* nsv|const char* key|I32 klen
p	|MAGIC*	|mg_find	|SV* sv|int type
p	|int	|mg_free	|SV* sv
p	|int	|mg_get		|SV* sv
p	|U32	|mg_length	|SV* sv
p	|void	|mg_magical	|SV* sv
p	|int	|mg_set		|SV* sv
p	|I32	|mg_size	|SV* sv
p	|OP*	|mod		|OP* o|I32 type
p	|char*	|moreswitches	|char* s
p	|OP*	|my		|OP* o
c[!defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)] \
p	|char*	|my_bcopy	|const char* from|char* to|I32 len
c[!defined(HAS_BZERO) && !defined(HAS_MEMSET)] \
p	|char*	|my_bzero	|char* loc|I32 len
pr	|void	|my_exit	|U32 status
pr	|void	|my_failure_exit
p	|I32	|my_fflush_all
p	|I32	|my_lstat	|ARGSproto
c[!defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)] \
p	|I32	|my_memcmp	|const char* s1|const char* s2|I32 len
c[!defined(HAS_MEMSET)] \
p	|void*	|my_memset	|char* loc|I32 ch|I32 len
c[!defined(PERL_OBJECT)] \
p	|I32	|my_pclose	|PerlIO* ptr
c[!defined(PERL_OBJECT)] \
p	|PerlIO*|my_popen	|char* cmd|char* mode
p	|void	|my_setenv	|char* nam|char* val
p	|I32	|my_stat	|ARGSproto
c[defined(MYSWAP)] \
p	|short	|my_swap	|short s
c[defined(MYSWAP)] \
p	|long	|my_htonl	|long l
c[defined(MYSWAP)] \
p	|long	|my_ntohl	|long l
p	|void	|my_unexec
p	|OP*	|newANONLIST	|OP* o
p	|OP*	|newANONHASH	|OP* o
p	|OP*	|newANONSUB	|I32 floor|OP* proto|OP* block
p	|OP*	|newASSIGNOP	|I32 flags|OP* left|I32 optype|OP* right
p	|OP*	|newCONDOP	|I32 flags|OP* expr|OP* trueop|OP* falseop
p	|void	|newCONSTSUB	|HV* stash|char* name|SV* sv
p	|void	|newFORM	|I32 floor|OP* o|OP* block
p	|OP*	|newFOROP	|I32 flags|char* label|line_t forline \
				|OP* sclr|OP* expr|OP*block|OP*cont
p	|OP*	|newLOGOP	|I32 optype|I32 flags|OP* left|OP* right
p	|OP*	|newLOOPEX	|I32 type|OP* label
p	|OP*	|newLOOPOP	|I32 flags|I32 debuggable|OP* expr|OP* block
p	|OP*	|newNULLLIST
p	|OP*	|newOP		|I32 optype|I32 flags
p	|void	|newPROG	|OP* o
p	|OP*	|newRANGE	|I32 flags|OP* left|OP* right
p	|OP*	|newSLICEOP	|I32 flags|OP* subscript|OP* listop
p	|OP*	|newSTATEOP	|I32 flags|char* label|OP* o
p	|CV*	|newSUB		|I32 floor|OP* o|OP* proto|OP* block
p	|CV*	|newXS		|char* name|XSUBADDR_t f|char* filename
p	|AV*	|newAV
p	|OP*	|newAVREF	|OP* o
p	|OP*	|newBINOP	|I32 type|I32 flags|OP* first|OP* last
p	|OP*	|newCVREF	|I32 flags|OP* o
p	|OP*	|newGVOP	|I32 type|I32 flags|GV* gv
p	|GV*	|newGVgen	|char* pack
p	|OP*	|newGVREF	|I32 type|OP* o
p	|OP*	|newHVREF	|OP* o
p	|HV*	|newHV
p	|HV*	|newHVhv	|HV* hv
p	|IO*	|newIO
p	|OP*	|newLISTOP	|I32 type|I32 flags|OP* first|OP* last
p	|OP*	|newPMOP	|I32 type|I32 flags
p	|OP*	|newPVOP	|I32 type|I32 flags|char* pv
p	|SV*	|newRV		|SV* pref
p	|SV*	|newRV_noinc	|SV *sv
p	|SV*	|newSV		|STRLEN len
p	|OP*	|newSVREF	|OP* o
p	|OP*	|newSVOP	|I32 type|I32 flags|SV* sv
p	|SV*	|newSViv	|IV i
p	|SV*	|newSVnv	|double n
p	|SV*	|newSVpv	|const char* s|STRLEN len
p	|SV*	|newSVpvn	|const char* s|STRLEN len
p	|SV*	|newSVpvf	|const char* pat|...
p	|SV*	|newSVrv	|SV* rv|const char* classname
p	|SV*	|newSVsv	|SV* old
p	|OP*	|newUNOP	|I32 type|I32 flags|OP* first
p	|OP*	|newWHILEOP	|I32 flags|I32 debuggable|LOOP* loop \
				|I32 whileline|OP* expr|OP* block|OP* cont
c[defined(USE_THREADS)] \
p	|struct perl_thread*|new_struct_thread|struct perl_thread *t
p	|PERL_SI*|new_stackinfo|I32 stitems|I32 cxitems
p	|PerlIO*|nextargv	|GV* gv
p	|char*	|ninstr		|const char* big|const char* bigend \
				|const char* little|const char* lend
p	|OP*	|oopsCV		|OP* o
p	|void	|op_free	|OP* arg
p	|void	|package	|OP* o
p	|PADOFFSET|pad_alloc	|I32 optype|U32 tmptype
p	|PADOFFSET|pad_allocmy	|char* name
p	|PADOFFSET|pad_findmy	|char* name
p	|OP*	|oopsAV		|OP* o
p	|OP*	|oopsHV		|OP* o
p	|void	|pad_leavemy	|I32 fill
p	|SV*	|pad_sv		|PADOFFSET po
p	|void	|pad_free	|PADOFFSET po
p	|void	|pad_reset
p	|void	|pad_swipe	|PADOFFSET po
p	|void	|peep		|OP* o
c[!defined(PERL_OBJECT)] \
n	|PerlInterpreter*	|perl_alloc
p	|void	|call_atexit	|ATEXIT_t fn|void *ptr
p	|I32	|call_argv	|const char* sub_name|I32 flags|char** argv
p	|I32	|call_method	|const char* methname|I32 flags
p	|I32	|call_pv	|const char* sub_name|I32 flags
p	|I32	|call_sv	|SV* sv|I32 flags
n	|void	|perl_construct	|PerlInterpreter* sv_interp
n	|void	|perl_destruct	|PerlInterpreter* sv_interp
p	|SV*	|eval_pv	|const char* p|I32 croak_on_error
p	|I32	|eval_sv	|SV* sv|I32 flags
n	|void	|perl_free	|PerlInterpreter* sv_interp
p	|SV*	|get_sv		|const char* name|I32 create
p	|AV*	|get_av		|const char* name|I32 create
p	|HV*	|get_hv		|const char* name|I32 create
p	|CV*	|get_cv		|const char* name|I32 create
p	|int	|init_i18nl10n	|int printwarn
p	|int	|init_i18nl14n	|int printwarn
p	|void	|new_collate	|const char* newcoll
p	|void	|new_ctype	|const char* newctype
p	|void	|new_numeric	|const char* newcoll
p	|void	|set_numeric_local
p	|void	|set_numeric_standard
n	|int	|perl_parse	|PerlInterpreter* sv_interp|XSINIT_t xsinit \
				|int argc|char** argv|char** env
p	|void	|require_pv	|const char* pv
n	|int	|perl_run	|PerlInterpreter* sv_interp
p	|void	|pidgone	|int pid|int status
p	|void	|pmflag		|U16* pmfl|int ch
p	|OP*	|pmruntime	|OP* pm|OP* expr|OP* repl
p	|OP*	|pmtrans	|OP* o|OP* expr|OP* repl
p	|OP*	|pop_return
p	|void	|pop_scope
p	|OP*	|prepend_elem	|I32 optype|OP* head|OP* tail
p	|void	|push_return	|OP* o
p	|void	|push_scope
p	|OP*	|ref		|OP* o|I32 type
p	|OP*	|refkids	|OP* o|I32 type
p	|void	|regdump	|regexp* r
p	|I32	|pregexec	|regexp* prog|char* stringarg \
				|char* strend|char* strbeg|I32 minend \
				|SV* screamer|U32 nosave
p	|void	|pregfree	|struct regexp* r
p	|regexp*|pregcomp	|char* exp|char* xend|PMOP* pm
p	|I32	|regexec_flags	|regexp* prog|char* stringarg \
				|char* strend|char* strbeg|I32 minend \
				|SV* screamer|void* data|U32 flags
p	|regnode*|regnext	|regnode* p
p	|void	|regprop	|SV* sv|regnode* o
p	|void	|repeatcpy	|char* to|const char* from|I32 len|I32 count
p	|char*	|rninstr	|const char* big|const char* bigend \
				|const char* little|const char* lend
p	|Sighandler_t|rsignal	|int i|Sighandler_t t
p	|int	|rsignal_restore|int i|Sigsave_t* t
p	|int	|rsignal_save	|int i|Sighandler_t t1|Sigsave_t* t2
p	|Sighandler_t|rsignal_state|int i
p	|void	|rxres_free	|void** rsp
p	|void	|rxres_restore	|void** rsp|REGEXP* prx
p	|void	|rxres_save	|void** rsp|REGEXP* prx
c[!defined(HAS_RENAME)] \
p	|I32	|same_dirent	|char* a|char* b
p	|char*	|savepv		|const char* sv
p	|char*	|savepvn	|const char* sv|I32 len
p	|void	|savestack_grow
p	|void	|save_aelem	|AV* av|I32 idx|SV **sptr
p	|I32	|save_alloc	|I32 size|I32 pad
p	|void	|save_aptr	|AV** aptr
p	|AV*	|save_ary	|GV* gv
p	|void	|save_clearsv	|SV** svp
p	|void	|save_delete	|HV* hv|char* key|I32 klen
p	|void	|save_destructor|DESTRUCTORFUNC_t f|void* p
p	|void	|save_freesv	|SV* sv
p	|void	|save_freeop	|OP* o
p	|void	|save_freepv	|char* pv
p	|void	|save_generic_svref|SV** sptr
p	|void	|save_gp	|GV* gv|I32 empty
p	|HV*	|save_hash	|GV* gv
p	|void	|save_helem	|HV* hv|SV *key|SV **sptr
p	|void	|save_hints
p	|void	|save_hptr	|HV** hptr
p	|void	|save_I16	|I16* intp
p	|void	|save_I32	|I32* intp
p	|void	|save_int	|int* intp
p	|void	|save_item	|SV* item
p	|void	|save_iv	|IV* iv
p	|void	|save_list	|SV** sarg|I32 maxsarg
p	|void	|save_long	|long* longp
p	|void	|save_nogv	|GV* gv
p	|void	|save_op
p	|SV*	|save_scalar	|GV* gv
p	|void	|save_pptr	|char** pptr
p	|void	|save_re_context
p	|void	|save_sptr	|SV** sptr
p	|SV*	|save_svref	|SV** sptr
p	|SV**	|save_threadsv	|PADOFFSET i
p	|OP*	|sawparens	|OP* o
p	|OP*	|scalar		|OP* o
p	|OP*	|scalarkids	|OP* o
p	|OP*	|scalarseq	|OP* o
p	|OP*	|scalarvoid	|OP* o
p	|UV	|scan_bin	|char* start|I32 len|I32* retlen
p	|UV	|scan_hex	|char* start|I32 len|I32* retlen
p	|char*	|scan_num	|char* s
p	|UV	|scan_oct	|char* start|I32 len|I32* retlen
p	|OP*	|scope		|OP* o
p	|char*	|screaminstr	|SV* bigsv|SV* littlesv|I32 start_shift \
				|I32 end_shift|I32 *state|I32 last
c[!defined(VMS)] \
p	|I32	|setenv_getix	|char* nam
p	|void	|setdefout	|GV* gv
p	|char*	|sharepvn	|const char* sv|I32 len|U32 hash
p	|HEK*	|share_hek	|const char* sv|I32 len|U32 hash
p	|Signal_t |sighandler	|int sig
p	|SV**	|stack_grow	|SV** sp|SV**p|int n
p	|I32	|start_subparse	|I32 is_format|U32 flags
p	|void	|sub_crush_depth|CV* cv
p	|bool	|sv_2bool	|SV* sv
p	|CV*	|sv_2cv		|SV* sv|HV** st|GV** gvp|I32 lref
p	|IO*	|sv_2io		|SV* sv
p	|IV	|sv_2iv		|SV* sv
p	|SV*	|sv_2mortal	|SV* sv
p	|double	|sv_2nv		|SV* sv
p	|char*	|sv_2pv		|SV* sv|STRLEN* lp
p	|UV	|sv_2uv		|SV* sv
p	|IV	|sv_iv		|SV* sv
p	|UV	|sv_uv		|SV* sv
p	|double	|sv_nv		|SV* sv
p	|char*	|sv_pvn		|SV *sv|STRLEN *len
p	|I32	|sv_true	|SV *sv
p	|void	|sv_add_arena	|char* ptr|U32 size|U32 flags
p	|int	|sv_backoff	|SV* sv
p	|SV*	|sv_bless	|SV* sv|HV* stash
p	|void	|sv_catpvf	|SV* sv|const char* pat|...
p	|void	|sv_catpv	|SV* sv|const char* ptr
p	|void	|sv_catpvn	|SV* sv|const char* ptr|STRLEN len
p	|void	|sv_catsv	|SV* dsv|SV* ssv
p	|void	|sv_chop	|SV* sv|char* ptr
p	|void	|sv_clean_all
p	|void	|sv_clean_objs
p	|void	|sv_clear	|SV* sv
p	|I32	|sv_cmp		|SV* sv1|SV* sv2
p	|I32	|sv_cmp_locale	|SV* sv1|SV* sv2
c[defined(USE_LOCALE_COLLATE)] \
p	|char*	|sv_collxfrm	|SV* sv|STRLEN* nxp
p	|OP*	|sv_compile_2op	|SV* sv|OP** startp|char* code|AV** avp
p	|void	|sv_dec		|SV* sv
p	|void	|sv_dump	|SV* sv
p	|bool	|sv_derived_from|SV* sv|const char* name
p	|I32	|sv_eq		|SV* sv1|SV* sv2
p	|void	|sv_free	|SV* sv
p	|void	|sv_free_arenas
p	|char*	|sv_gets	|SV* sv|PerlIO* fp|I32 append
p	|char*	|sv_grow	|SV* sv|STRLEN newlen
p	|void	|sv_inc		|SV* sv
p	|void	|sv_insert	|SV* bigsv|STRLEN offset|STRLEN len \
				|char* little|STRLEN littlelen
p	|int	|sv_isa		|SV* sv|const char* name
p	|int	|sv_isobject	|SV* sv
p	|STRLEN	|sv_len		|SV* sv
p	|STRLEN	|sv_len_utf8	|SV* sv
p	|void	|sv_magic	|SV* sv|SV* obj|int how|const char* name \
				|I32 namlen
p	|SV*	|sv_mortalcopy	|SV* oldsv
p	|SV*	|sv_newmortal
p	|SV*	|sv_newref	|SV* sv
p	|char*	|sv_peek	|SV* sv
p	|void	|sv_pos_u2b	|SV* sv|I32* offsetp|I32* lenp
p	|void	|sv_pos_b2u	|SV* sv|I32* offsetp
p	|char*	|sv_pvn_force	|SV* sv|STRLEN* lp
p	|char*	|sv_reftype	|SV* sv|int ob
p	|void	|sv_replace	|SV* sv|SV* nsv
p	|void	|sv_report_used
p	|void	|sv_reset	|char* s|HV* stash
p	|void	|sv_setpvf	|SV* sv|const char* pat|...
p	|void	|sv_setiv	|SV* sv|IV num
p	|void	|sv_setpviv	|SV* sv|IV num
p	|void	|sv_setuv	|SV* sv|UV num
p	|void	|sv_setnv	|SV* sv|double num
p	|SV*	|sv_setref_iv	|SV* rv|const char* classname|IV iv
p	|SV*	|sv_setref_nv	|SV* rv|const char* classname|double nv
p	|SV*	|sv_setref_pv	|SV* rv|const char* classname|void* pv
p	|SV*	|sv_setref_pvn	|SV* rv|const char* classname|char* pv \
				|STRLEN n
p	|void	|sv_setpv	|SV* sv|const char* ptr
p	|void	|sv_setpvn	|SV* sv|const char* ptr|STRLEN len
p	|void	|sv_setsv	|SV* dsv|SV* ssv
p	|void	|sv_taint	|SV* sv
p	|bool	|sv_tainted	|SV* sv
p	|int	|sv_unmagic	|SV* sv|int type
p	|void	|sv_unref	|SV* sv
p	|void	|sv_untaint	|SV* sv
p	|bool	|sv_upgrade	|SV* sv|U32 mt
p	|void	|sv_usepvn	|SV* sv|char* ptr|STRLEN len
p	|void	|sv_vcatpvfn	|SV* sv|const char* pat|STRLEN patlen \
				|va_list* args|SV** svargs|I32 svmax \
				|bool *used_locale
p	|void	|sv_vsetpvfn	|SV* sv|const char* pat|STRLEN patlen \
				|va_list* args|SV** svargs|I32 svmax \
				|bool *used_locale
p	|SV*	|swash_init	|char* pkg|char* name|SV* listsv \
				|I32 minbits|I32 none
p	|UV	|swash_fetch	|SV *sv|U8 *ptr
p	|void	|taint_env
p	|void	|taint_proper	|const char* f|char* s
p	|UV	|to_utf8_lower	|U8 *p
p	|UV	|to_utf8_upper	|U8 *p
p	|UV	|to_utf8_title	|U8 *p
c[defined(UNLINK_ALL_VERSIONS)] \
p	|I32	|unlnk		|char* f
c[defined(USE_THREADS)] \
p	|void	|unlock_condpair|void* svv
p	|void	|unsharepvn	|const char* sv|I32 len|U32 hash
p	|void	|unshare_hek	|HEK* hek
p	|void	|utilize	|int aver|I32 floor|OP* version|OP* id|OP* arg
p	|U8*	|utf16_to_utf8	|U16* p|U8 *d|I32 bytelen
p	|U8*	|utf16_to_utf8_reversed|U16* p|U8 *d|I32 bytelen
p	|I32	|utf8_distance	|U8 *a|U8 *b
p	|U8*	|utf8_hop	|U8 *s|I32 off
p	|UV	|utf8_to_uv	|U8 *s|I32* retlen
p	|U8*	|uv_to_utf8	|U8 *d|UV uv
p	|void	|vivify_defelem	|SV* sv
p	|void	|vivify_ref	|SV* sv|U32 to_what
p	|I32	|wait4pid	|int pid|int* statusp|int flags
p	|void	|warn		|const char* pat|...
p	|void	|warner		|U32 err|const char* pat|...
p	|void	|watch		|char** addr
p	|I32	|whichsig	|char* sig
p	|int	|yyerror	|char* s
c[!defined(USE_PURE_BISON)] \
p	|int	|yylex
p	|int	|yyparse
p	|int	|yywarn		|char* s
c[defined(MYMALLOC)] \
p	|void	|dump_mstats	|char* s
c[defined(MYMALLOC)] \
p	|Malloc_t|malloc	|MEM_SIZE nbytes
c[defined(MYMALLOC)] \
p	|Malloc_t|calloc	|MEM_SIZE elements|MEM_SIZE size
c[defined(MYMALLOC)] \
p	|Malloc_t|realloc	|Malloc_t where|MEM_SIZE nbytes
c[defined(MYMALLOC)] \
p	|Free_t	|mfree		|Malloc_t where
p	|Malloc_t|safesysmalloc	|MEM_SIZE nbytes
p	|Malloc_t|safesyscalloc	|MEM_SIZE elements|MEM_SIZE size
p	|Malloc_t|safesysrealloc|Malloc_t where|MEM_SIZE nbytes
p	|Free_t	|safesysfree	|Malloc_t where
c[defined(LEAKTEST)] \
p	|Malloc_t|safexmalloc	|I32 x|MEM_SIZE size
c[defined(LEAKTEST)] \
p	|Malloc_t|safexcalloc	|I32 x|MEM_SIZE elements|MEM_SIZE size
c[defined(LEAKTEST)] \
p	|Malloc_t|safexrealloc	|Malloc_t where|MEM_SIZE size
c[defined(LEAKTEST)] \
p	|void	|safexfree	|Malloc_t where
c[defined(PERL_GLOBAL_STRUCT)] \
p	|struct perl_vars *|GetVars
p	|void	|yydestruct	|void *ptr
p	|int	|runops_standard
p	|int	|runops_debug

c[defined(WIN32)] \
p	|int&	|ErrorNo
p	|void	|sv_catpvf_mg	|SV *sv|const char* pat|...
p	|void	|sv_catpv_mg	|SV *sv|const char *ptr
p	|void	|sv_catpvn_mg	|SV *sv|const char *ptr|STRLEN len
p	|void	|sv_catsv_mg	|SV *dstr|SV *sstr
p	|void	|sv_setpvf_mg	|SV *sv|const char* pat|...
p	|void	|sv_setiv_mg	|SV *sv|IV i
p	|void	|sv_setpviv_mg	|SV *sv|IV iv
p	|void	|sv_setuv_mg	|SV *sv|UV u
p	|void	|sv_setnv_mg	|SV *sv|double num
p	|void	|sv_setpv_mg	|SV *sv|const char *ptr
p	|void	|sv_setpvn_mg	|SV *sv|const char *ptr|STRLEN len
p	|void	|sv_setsv_mg	|SV *dstr|SV *sstr
p	|void	|sv_usepvn_mg	|SV *sv|char *ptr|STRLEN len
p	|MGVTBL*|get_vtbl	|int vtbl_id
p	|char*	|pv_display	|SV *sv|char *pv|STRLEN cur|STRLEN len \
				|STRLEN pvlim
p	|void	|dump_indent	|I32 level|PerlIO *file|const char* pat|...
p	|void	|do_gv_dump	|I32 level|PerlIO *file|char *name|GV *sv
p	|void	|do_gvgv_dump	|I32 level|PerlIO *file|char *name|GV *sv
p	|void	|do_hv_dump	|I32 level|PerlIO *file|char *name|HV *sv
p	|void	|do_magic_dump	|I32 level|PerlIO *file|MAGIC *mg|I32 nest \
				|I32 maxnest|bool dumpops|STRLEN pvlim
p	|void	|do_op_dump	|I32 level|PerlIO *file|OP *o
p	|void	|do_pmop_dump	|I32 level|PerlIO *file|PMOP *pm
p	|void	|do_sv_dump	|I32 level|PerlIO *file|SV *sv|I32 nest \
				|I32 maxnest|bool dumpops|STRLEN pvlim
p	|void	|magic_dump	|MAGIC *mg
p	|void*	|default_protect|int *excpt|protect_body_t body|...
p	|void	|reginitcolors
p	|char*	|sv_2pv_nolen	|SV* sv
p	|char*	|sv_pv		|SV *sv
p	|void	|sv_force_normal|SV *sv
p	|void	|tmps_grow	|I32 n
p	|void*	|bset_obj_store	|void *obj|I32 ix
p	|SV*	|sv_rvweaken	|SV *sv
p	|int	|magic_killbackrefs|SV *sv|MAGIC *mg

s[av]	|I32	|avhv_index_sv	|SV* sv
s[hv]	|void	|hsplit		|HV *hv
s[hv]	|void	|hfreeentries	|HV *hv
s[hv]	|void	|more_he
s[hv]	|HE*	|new_he
s[hv]	|void	|del_he		|HE *p
s[hv]	|HEK*	|save_hek	|const char *str|I32 len|U32 hash
s[hv]	|void	|hv_magic_check	|HV *hv|bool *needs_copy|bool *needs_store
s[util]	|SV*	|mess_alloc
c[defined(LEAKTEST)] \
s[util]	|void	|xstat		|int
s[gv]	|void	|gv_init_sv	|GV *gv|I32 sv_type
s[scope]|SV*	|save_scalar_at	|SV **sptr
s[sv]	|IV	|asIV		|SV* sv
s[sv]	|UV	|asUV		|SV* sv
s[sv]	|SV*	|more_sv
s[sv]	|void	|more_xiv
s[sv]	|void	|more_xnv
s[sv]	|void	|more_xpv
s[sv]	|void	|more_xrv
s[sv]	|XPVIV*	|new_xiv
s[sv]	|XPVNV*	|new_xnv
s[sv]	|XPV*	|new_xpv
s[sv]	|XRV*	|new_xrv
s[sv]	|void	|del_xiv	|XPVIV* p
s[sv]	|void	|del_xnv	|XPVNV* p
s[sv]	|void	|del_xpv	|XPV* p
s[sv]	|void	|del_xrv	|XRV* p
s[sv]	|void	|sv_unglob	|SV* sv
s[sv]	|void	|do_report_used	|SV *sv
s[sv]	|void	|do_clean_objs	|SV *sv
s[sv]	|void	|do_clean_named_objs|SV *sv
s[sv]	|void	|do_clean_all	|SV *sv
s[sv]	|void	|not_a_number	|SV *sv
s[sv]	|void	|visit		|SVFUNC_t f
c[!defined(PURIFY)] \
s[sv]	|void*	|my_safemalloc	|MEM_SIZE size
c[defined(PURIFY)] \
s[sv]	|void	|reg_add	|SV *sv
c[defined(PURIFY)] \
s[sv]	|void	|reg_remove	|SV *sv
s[mg]	|void	|save_magic	|I32 mgs_ix|SV *sv
s[mg]	|int	|magic_methpack	|SV *sv|MAGIC *mg|char *meth
s[mg]	|int	|magic_methcall	|SV *sv|MAGIC *mg|char *meth|I32 f \
				|int n|SV *val
s[pp]	|void	|doencodes	|SV* sv|char* s|I32 len
s[pp]	|SV*	|refto		|SV* sv
s[pp]	|U32	|seed
s[perl]	|void*	|parse_body	|va_list args
s[perl]	|void*	|run_body	|va_list args
s[perl]	|void*	|call_body	|va_list args
s[perl]	|void	|call_xbody	|OP *myop|int is_eval
s[perl]	|void*	|call_list_body	|va_list args
s[pp_ctl]|OP*	|docatch	|OP *o
s[pp_ctl]|void*	|docatch_body	|va_list args
s[pp_ctl]|OP*	|dofindlabel	|OP *o|char *label|OP **opstack|OP **oplimit
s[pp_ctl]|void	|doparseform	|SV *sv
s[pp_ctl]|I32	|dopoptoeval	|I32 startingblock
s[pp_ctl]|I32	|dopoptolabel	|char *label
s[pp_ctl]|I32	|dopoptoloop	|I32 startingblock
s[pp_ctl]|I32	|dopoptosub	|I32 startingblock
s[pp_ctl]|I32	|dopoptosub_at	|PERL_CONTEXT* cxstk|I32 startingblock
s[pp_ctl]|void	|free_closures
s[pp_ctl]|void	|save_lines	|AV *array|SV *sv
s[pp_ctl]|OP*	|doeval		|int gimme|OP** startop
s[pp_ctl]|PerlIO *|doopen_pmc	|const char *name|const char *mode
s[pp_ctl]|void	|qsortsv	|SV ** array|size_t num_elts|SVCOMPARE_t f
s[pp_ctl]|I32	|sortcv		|SV *a|SV *b
s[pp_ctl]|I32	|sv_ncmp	|SV *a|SV *b
s[pp_ctl]|I32	|sv_i_ncmp	|SV *a|SV *b
s[pp_ctl]|I32	|amagic_ncmp	|SV *a|SV *b
s[pp_ctl]|I32	|amagic_i_ncmp	|SV *a|SV *b
s[pp_ctl]|I32	|amagic_cmp	|SV *str1|SV *str2
s[pp_ctl]|I32	|amagic_cmp_locale|SV *str1|SV *str2
s[pp]	|SV*	|mul128		|SV *sv|U8 m
s[pp]	|SV*	|is_an_int	|char *s|STRLEN l
s[pp]	|int	|div128		|SV *pnum|bool *done
s[toke]	|void	|check_uni
s[toke]	|void	|force_next	|I32 type
s[toke]	|char*	|force_version	|char *start
s[toke]	|char*	|force_word	|char *start|int token|int check_keyword \
				|int allow_pack|int allow_tick
s[toke]	|SV*	|tokeq		|SV *sv
s[toke]	|char*	|scan_const	|char *start
s[toke]	|char*	|scan_formline	|char *s
s[toke]	|char*	|scan_heredoc	|char *s
s[toke]	|char*	|scan_ident	|char *s|char *send|char *dest \
				|STRLEN destlen|I32 ck_uni
s[toke]	|char*	|scan_inputsymbol|char *start
s[toke]	|char*	|scan_pat	|char *start|I32 type
s[toke]	|char*	|scan_str	|char *start
s[toke]	|char*	|scan_subst	|char *start
s[toke]	|char*	|scan_trans	|char *start
s[toke]	|char*	|scan_word	|char *s|char *dest|STRLEN destlen \
				|int allow_package|STRLEN *slp
s[toke]	|char*	|skipspace	|char *s
s[toke]	|void	|checkcomma	|char *s|char *name|char *what
s[toke]	|void	|force_ident	|char *s|int kind
s[toke]	|void	|incline	|char *s
s[toke]	|int	|intuit_method	|char *s|GV *gv
s[toke]	|int	|intuit_more	|char *s
s[toke]	|I32	|lop		|I32 f|expectation x|char *s
s[toke]	|void	|missingterm	|char *s
s[toke]	|void	|no_op		|char *what|char *s
s[toke]	|void	|set_csh
s[toke]	|I32	|sublex_done
s[toke]	|I32	|sublex_push
s[toke]	|I32	|sublex_start
s[toke]	|char *	|filter_gets	|SV *sv|PerlIO *fp|STRLEN append
s[toke]	|SV*	|new_constant	|char *s|STRLEN len|char *key|SV *sv \
				|SV *pv|char *type
s[toke]	|int	|ao		|int toketype
s[toke]	|void	|depcom
s[toke]	|char*	|incl_perldb
s[toke]	|I32	|utf16_textfilter|int idx|SV *sv|int maxlen
s[toke]	|I32	|utf16rev_textfilter|int idx|SV *sv|int maxlen
s[universal]|SV*|isa_lookup	|HV *stash|const char *name|int len|int level
s[pp_hot]|CV*	|get_db_sub	|SV **svp|CV *cv
c[defined(USE_THREADS)] \
s[pp_hot]|void	|unset_cvowner	|void *cvarg
s[op]	|I32	|list_assignment|OP *o
s[op]	|void	|bad_type	|I32 n|char *t|char *name|OP *kid
s[op]	|OP*	|modkids	|OP *o|I32 type
s[op]	|void	|no_bareword_allowed|OP *o
s[op]	|OP*	|no_fh_allowed	|OP *o
s[op]	|OP*	|scalarboolean	|OP *o
s[op]	|OP*	|too_few_arguments|OP *o|char* name
s[op]	|OP*	|too_many_arguments|OP *o|char* name
s[op]	|void	|null		|OP* o
s[op]	|PADOFFSET|pad_findlex	|char* name|PADOFFSET newoff|U32 seq \
				|CV* startcv|I32 cx_ix|I32 saweval|U32 flags
s[op]	|OP*	|newDEFSVOP
s[op]	|OP*	|new_logop	|I32 type|I32 flags|OP **firstp|OP **otherp
s[op]	|void	|simplify_sort	|OP *o
s[op]	|bool	|is_handle_constructor	|OP *o|I32 argnum
s[op]	|char*	|gv_ename	|GV *gv
s[op]	|CV*	|cv_clone2	|CV *proto|CV *outside
s[op]	|bool	|scalar_mod_type|OP *o|I32 type
c[defined(PL_OP_SLAB_ALLOC)] \
s[op]	|void*	|Slab_Alloc	|int m|size_t sz
s[perl]	|void	|find_beginning
s[perl]	|void	|forbid_setid	|char *
s[perl]	|void	|incpush	|char *|int
s[perl]	|void	|init_interp
s[perl]	|void	|init_ids
s[perl]	|void	|init_debugger
s[perl]	|void	|init_lexer
s[perl]	|void	|init_main_stash
s[perl]	|void	|init_perllib
s[perl]	|void	|init_postdump_symbols|int|char **|char **
s[perl]	|void	|init_predump_symbols
rs[perl]|void	|my_exit_jump
s[perl]	|void	|nuke_stacks
s[perl]	|void	|open_script	|char *|bool|SV *|int *fd
s[perl]	|void	|usage		|char *
s[perl]	|void	|validate_suid	|char *|char*|int
s[perl]	|I32	|read_e_script	|int idx|SV *buf_sv|int maxlen
c[defined(IAMSUID)] \
s[perl]	|int	|fd_on_nosuid_fs|int fd
s[pp_sys]|OP*	|doform		|CV *cv|GV *gv|OP *retop
s[pp_sys]|int	|emulate_eaccess|const char* path|int mode
c[!defined(HAS_MKDIR) || !defined(HAS_RMDIR)] \
s[pp_sys]|int	|dooneliner	|char *cmd|char *filename
c[defined(FCNTL_EMULATE_FLOCK)] \
s[pp_sys]|int	|fcntl_emulate_flock|int fd|int operation
c[defined(LOCKF_EMULATE_FLOCK)] \
s[pp_sys]|int	|lockf_emulate_flock|int fd|int operation
s[regcomp]|regnode*|reg		|I32|I32 *
s[regcomp]|regnode*|reganode	|U8|U32
s[regcomp]|regnode*|regatom	|I32 *
s[regcomp]|regnode*|regbranch	|I32 *|I32
s[regcomp]|void	|regc		|U8|char *
s[regcomp]|void	|reguni		|UV|char *|I32*
s[regcomp]|regnode*|regclass
s[regcomp]|regnode*|regclassutf8
s[regcomp]|I32	|regcurly	|char *
s[regcomp]|regnode*|reg_node	|U8
s[regcomp]|regnode*|regpiece	|I32 *
s[regcomp]|void	|reginsert	|U8|regnode *
s[regcomp]|void	|regoptail	|regnode *|regnode *
s[regcomp]|void	|regset		|char *|I32
s[regcomp]|void	|regtail	|regnode *|regnode *
s[regcomp]|char*|regwhite	|char *|char *
s[regcomp]|char*|nextchar
s[regcomp]|regnode*|dumpuntil	|regnode *start|regnode *node \
				|regnode *last|SV* sv|I32 l
s[regcomp]|void	|scan_commit	|scan_data_t *data
s[regcomp]|I32	|study_chunk	|regnode **scanp|I32 *deltap \
				|regnode *last|scan_data_t *data|U32 flags
s[regcomp]|I32	|add_data	|I32 n|char *s
rs[regcomp]|void|re_croak2	|const char* pat1|const char* pat2|...
s[regcomp]|char*|regpposixcc	|I32 value
s[regcomp]|void	|clear_re	|void *r
s[regexec]|I32	|regmatch	|regnode *prog
s[regexec]|I32	|regrepeat	|regnode *p|I32 max
s[regexec]|I32	|regrepeat_hard	|regnode *p|I32 max|I32 *lp
s[regexec]|I32	|regtry		|regexp *prog|char *startpos
s[regexec]|bool	|reginclass	|char *p|I32 c
s[regexec]|bool	|reginclassutf8	|regnode *f|U8* p
s[regexec]|CHECKPOINT|regcppush	|I32 parenfloor
s[regexec]|char*|regcppop
s[regexec]|char*|regcp_set_to	|I32 ss
s[regexec]|void	|cache_re	|regexp *prog
s[regexec]|void	|restore_pos	|void *arg
s[regexec]|U8*	|reghop		|U8 *pos|I32 off
s[regexec]|U8*	|reghopmaybe	|U8 *pos|I32 off
s[run]	|void	|debprof	|OP *o
s[sv]	|void	|sv_add_backref	|SV *tsv|SV *sv
s[sv]	|void	|sv_del_backref	|SV *sv
s[doop]	|I32	|do_trans_CC_simple	|SV *sv
s[doop]	|I32	|do_trans_CC_count	|SV *sv
s[doop]	|I32	|do_trans_CC_complex	|SV *sv
s[doop]	|I32	|do_trans_UU_simple	|SV *sv
s[doop]	|I32	|do_trans_UU_count	|SV *sv
s[doop]	|I32	|do_trans_UU_complex	|SV *sv
s[doop]	|I32	|do_trans_UC_simple	|SV *sv
s[doop]	|I32	|do_trans_CU_simple	|SV *sv
s[doop]	|I32	|do_trans_UC_trivial	|SV *sv
s[doop]	|I32	|do_trans_CU_trivial	|SV *sv
s[mg]	|void	|unwind_handler_stack	|void *p
s[mg]	|void	|restore_magic	|void *p
s[toke]	|void	|restore_rsfp	|void *f
s[toke]	|void	|restore_expect	|void *e
s[toke]	|void	|restore_lex_expect	|void *e
c[defined(USE_THREADS)] \
s[perl]	|struct perl_thread *	|init_main_thread
c[defined(WIN32)] \
s[globals]|int	|do_aspawn	|void *vreally|void **vmark|void **vsp
c[defined(DEBUGGING)] \
s[sv]	|void	|del_sv	|SV *p
c[defined(WIN32)] \
s[toke]	|I32	|win32_textfilter	|int idx|SV *sv|int maxlen
c[defined(CRIPPLED_CC)] \
s[toke]	|int	|uni		|I32 f|char *s
c[defined(MYMALLOC) && defined(DEBUGGING)] \
s[malloc]|void	|botch		|char *diag|char *s
c[defined(MYMALLOC)] \
s[malloc]|void	|morecore	|int bucket
c[defined(MYMALLOC)] \
s[malloc]|void	|add_to_chain	|void *p|MEM_SIZE size|MEM_SIZE chip
c[defined(MYMALLOC)] \
s[malloc]|Malloc_t|emergency_sbrk|MEM_SIZE size
c[defined(MYMALLOC)] \
s[malloc]|void*	|get_from_chain	|MEM_SIZE size
c[defined(MYMALLOC)] \
s[malloc]|void*	|get_from_bigger_buckets|int bucket|MEM_SIZE size
c[defined(MYMALLOC)] \
s[malloc]|union overhead *|getpages|int needed|int *nblksp|int bucket
c[defined(MYMALLOC)] \
s[malloc]|int	|getpages_adjacent|int require
