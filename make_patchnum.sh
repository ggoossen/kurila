#!/bin/sh

# this script is used to regenerate a number of special build files
# based on either information contained in a file called .patch or
# directly from git.
# The files involved are:
#   .patchnum         # information about the current checkout
#   lib/Config_git.pl # holds some special configure settings related to git
#   unpushed.h        # header file used by patchlevel.h to store unpushed commits

existing_patchnum=`cat .patchnum 2>/dev/null`
existing_config=`cat lib/Config_git.pl 2>/dev/null`
existing_unpushed=`cat unpushed.h 2>/dev/null`

unpushed_commits='/*no-op*/'
if [ -s ".patch" ] ; then
	read branch snapshot_created commit_id describe < .patch
	changed=""
	extra_info="git_snapshot_date='$snapshot_created'"
	commit_title='Snapshot of:'
elif [ -d ".git" ]; then
	branch=`git branch | awk 'BEGIN{ORS=""} /\*/ { print $2 }'`
	test -n "$branch" && remote=`git config branch.$branch.remote`
	commit_id=`git rev-parse HEAD`
	changed=`git diff-index --name-only HEAD`
	describe=`git describe --tags`
	commit_created=`git log -1 --pretty='format:%ci'`
	new_patchnum="describe: $describe"
	extra_info="git_commit_date='$commit_created'"
	if [ -n "$branch" ] && [ -n "$remote" ]; then
		unpushed_commit_list=`git cherry $remote/$branch | awk 'BEGIN{ORS=","} /\+/ {print $2}' | sed -e 's/,$//'`
		unpushed_commits=`git cherry $remote/$branch | awk 'BEGIN{ORS="\t\\\\\n"} /\+/ {print ",\"" $2 "\""}'`

		if [ -n "$unpushed_commits" ]; then
			commit_title="Local Commit:"
			ancestor=`git rev-parse $remote/$branch`
			extra_info="$extra_info
git_ancestor='$ancestor'
git_unpushed='$unpushed_commit_list'"
		fi
			
	fi
	if [ -n "$changed" ]; then
		changed="true"
		commit_title="Derived from:"
		new_patchnum="$new_patchnum
status: uncommitted-changes"
	fi
	test -z "$commit_title" && commit_title='Commit id:'
fi

new_unpushed=`cat <<EOFTEXT
/*********************************************************************
* WARNING: unpushed.h is automatically generated by make_patchnum.sh *
*          DO NOT EDIT DIRECTLY - edit make_patchnum.sh instead      *
*********************************************************************/
#define PERL_GIT_UNPUSHED_COMMITS       $unpushed_commits
/*leave-this-comment*/
EOFTEXT
`
new_config=`cat <<EOFDATA
#################################################################
# WARNING: lib/Config_git.pl is generated by make_patchnum.sh   #
#          DO NOT EDIT DIRECTLY - edit make_patchnum.sh instead #
#################################################################
\\$Config::Git_Data=<<'ENDOFGIT';
git_commit_id='$commit_id'
git_describe='$describe'
git_branch='$branch'
git_uncommitted_changes='$changed'
git_commit_id_title='$commit_title'
$extra_info
ENDOFGIT
EOFDATA
`
# only update the files if necessary, other build product depends on these files
if [ "$existing_patchnum" != "$new_patchnum" ] || [ "$new_config" != "$existing_config" ] || [ "$existing_unpushed" != "$new_unpushed" ]; then
	echo "Updating .patchnum and lib/Config_git.pl"
	echo "$new_patchnum" > .patchnum
	echo "$new_config" > lib/Config_git.pl
	echo "$new_unpushed" > unpushed.h
else
	echo "Reusing .patchnum and lib/Config_git.pl"
fi

