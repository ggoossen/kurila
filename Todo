Check out always the latest perl5-porters discussions on these subjects
before embaring on an implementation tour.

Tie Modules
	VecArray		Implement array using vec()
	SubstrArray		Implement array using substr()
	VirtualArray		Implement array using a file
	ShiftSplice		Defines shift et al in terms of splice method

Would be nice to have
	pack "(stuff)*", "(stuff)4", ...
	Contiguous bitfields in pack/unpack
	lexperl
	Bundled perl preprocessor
	Use posix calls internally where possible
	gettimeofday (possibly best left for a module?)
	format BOTTOM
	-i rename file only when successfully changed
	All ARGV input should act like <>
	report HANDLE [formats].
	support in perlmain to rerun debugger
	regression tests using __DIE__ hook
	reference to compiled regexp
	lexically scoped functions: my sub foo { ... }
	lvalue functions
	    wantlvalue?  more generalized want()?
	named prototypes: sub ($foo, @bar) foo { ... }
	regression/sanity tests for suidperl
	iterators/lazy evaluation/continuations/first/
	    first_defined/short-circuiting grep/??
	    This is a very thorny and hotly debated subject,
	    tread carefully and do your homework first.
	Full 64 bit support (i.e. "long long").  Things to consider:
	    how to store/retrieve 32+ integers into/from Perl scalars?
	    32+ constants in Perl code? (non-portable!)
	    32+ arguments/return values to/from system calls? (seek et al)
	    32+ bit ops (&|^~, currently explicitly disabled)
	Generalise Errno way of extracting cpp symbols and use that in
	    Errno and Fcntl (ExtUtils::CppSymbol?)
	The _r-problem: for all the {set,get,end}*() system database
	     calls (and a couple more: readdir, *rand*, crypt, *time,
	     tmpnam) there are in many systems the _r versions
	     to be used in re-entrant (=multithreaded) code.
	     Icky things: the _r API is not standardized and
	     the _r-forms require per-thread data to store their state.
	Memory profiler: turn malloc.c:Perl_dump_mstats() into
	    an extension (Devel::MProf?) that would return the malloc
	    stats in a nice Perl datastructure (also a simple interface
	    to return just the grand total would be good).

Possible pragmas
	debugger
	optimize (use less memory, CPU)

Optimizations
	constant function cache
	switch structures
	foreach(reverse...)
	Set KEEP on constant split
	Cache eval tree (unless lexical outer scope used (mark in &compiling?))
	rcatmaybe
	Shrink opcode tables via multiple implementations selected in peep
	Cache hash value?  (Not a win, according to Guido)
	Optimize away @_ where possible
	"one pass" global destruction
	Rewrite regexp parser for better integrated optimization
	LRU cache of regexp: foreach $pat (@pats) { foo() if /$pat/ }

Vague possibilities
	ref function in list context
	make tr/// return histogram in list context?
	Loop control on do{} et al
	Explicit switch statements
	built-in globbing
	compile to real threaded code
	structured types
	autocroak?
	Modifiable $1 et al

