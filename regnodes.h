/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regcomp.pl from regcomp.sym.  
   Any changes made here will be lost!
*/

#define	END	0	/*    0 End of program. */
#define	SUCCEED	1	/*  0x1 Return from a subroutine, basically. */
#define	BOL	2	/*  0x2 Match "" at beginning of line. */
#define	MBOL	3	/*  0x3 Same, assuming multiline. */
#define	SBOL	4	/*  0x4 Same, assuming singleline. */
#define	EOL	5	/*  0x5 Match "" at end of line. */
#define	MEOL	6	/*  0x6 Same, assuming multiline. */
#define	SEOL	7	/*  0x7 Same, assuming singleline. */
#define	BOUND	8	/*  0x8 Match "" at any word boundary */
#define	BOUNDL	9	/*  0x9 Match "" at any word boundary */
#define	NBOUND	10	/*  0xa Match "" at any word non-boundary */
#define	NBOUNDL	11	/*  0xb Match "" at any word non-boundary */
#define	GPOS	12	/*  0xc Matches where last m//g left off. */
#define	ANY	13	/*  0xd Match any one character (except newline). */
#define	SANY	14	/*  0xe Match any one character. */
#define	ANYOF	15	/*  0xf Match character in (or not in) this class. */
#define	ALNUM	16	/* 0x10 Match any alphanumeric character */
#define	ALNUML	17	/* 0x11 Match any alphanumeric char in locale */
#define	NALNUM	18	/* 0x12 Match any non-alphanumeric character */
#define	NALNUML	19	/* 0x13 Match any non-alphanumeric char in locale */
#define	SPACE	20	/* 0x14 Match any whitespace character */
#define	SPACEL	21	/* 0x15 Match any whitespace char in locale */
#define	NSPACE	22	/* 0x16 Match any non-whitespace character */
#define	NSPACEL	23	/* 0x17 Match any non-whitespace char in locale */
#define	DIGIT	24	/* 0x18 Match any numeric character */
#define	NDIGIT	25	/* 0x19 Match any non-numeric character */
#define	BRANCH	26	/* 0x1a Match this alternative, or the next... */
#define	BACK	27	/* 0x1b Match "", "next" ptr points backward. */
#define	EXACT	28	/* 0x1c Match this string (preceded by length). */
#define	EXACTF	29	/* 0x1d Match this string, folded (prec. by length). */
#define	EXACTFL	30	/* 0x1e Match this string, folded in locale (w/len). */
#define	NOTHING	31	/* 0x1f Match empty string. */
#define	TAIL	32	/* 0x20 Match empty string. Can jump here from outside. */
#define	STAR	33	/* 0x21 Match this (simple) thing 0 or more times. */
#define	PLUS	34	/* 0x22 Match this (simple) thing 1 or more times. */
#define	CURLY	35	/* 0x23 Match this simple thing {n,m} times. */
#define	CURLYN	36	/* 0x24 Match next-after-this simple thing  */
#define	CURLYM	37	/* 0x25 Match this medium-complex thing {n,m} times. */
#define	CURLYX	38	/* 0x26 Match this complex thing {n,m} times. */
#define	WHILEM	39	/* 0x27 Do curly processing and see if rest matches. */
#define	OPEN	40	/* 0x28 Mark this point in input as start of #n. */
#define	CLOSE	41	/* 0x29 Analogous to OPEN. */
#define	REF	42	/* 0x2a Match some already matched string */
#define	REFF	43	/* 0x2b Match already matched string, folded */
#define	REFFL	44	/* 0x2c Match already matched string, folded in loc. */
#define	IFMATCH	45	/* 0x2d Succeeds if the following matches. */
#define	UNLESSM	46	/* 0x2e Fails if the following matches. */
#define	SUSPEND	47	/* 0x2f "Independent" sub-RE. */
#define	IFTHEN	48	/* 0x30 Switch, should be preceeded by switcher . */
#define	GROUPP	49	/* 0x31 Whether the group matched. */
#define	LONGJMP	50	/* 0x32 Jump far away. */
#define	BRANCHJ	51	/* 0x33 BRANCH with long offset. */
#define	EVAL	52	/* 0x34 Execute some Perl code. */
#define	MINMOD	53	/* 0x35 Next operator is not greedy. */
#define	LOGICAL	54	/* 0x36 Next opcode should set the flag only. */
#define	RENUM	55	/* 0x37 Group with independently numbered parens. */
#define	OPTIMIZED	56	/* 0x38 Placeholder for dump. */

#ifndef DOINIT
EXTCONST U8 regkind[];
#else
EXTCONST U8 regkind[] = {
	END,		/* END */
	END,		/* SUCCEED */
	BOL,		/* BOL */
	BOL,		/* MBOL */
	BOL,		/* SBOL */
	EOL,		/* EOL */
	EOL,		/* MEOL */
	EOL,		/* SEOL */
	BOUND,		/* BOUND */
	BOUND,		/* BOUNDL */
	NBOUND,		/* NBOUND */
	NBOUND,		/* NBOUNDL */
	GPOS,		/* GPOS */
	ANY,		/* ANY */
	ANY,		/* SANY */
	ANYOF,		/* ANYOF */
	ALNUM,		/* ALNUM */
	ALNUM,		/* ALNUML */
	NALNUM,		/* NALNUM */
	NALNUM,		/* NALNUML */
	SPACE,		/* SPACE */
	SPACE,		/* SPACEL */
	NSPACE,		/* NSPACE */
	NSPACE,		/* NSPACEL */
	DIGIT,		/* DIGIT */
	NDIGIT,		/* NDIGIT */
	BRANCH,		/* BRANCH */
	BACK,		/* BACK */
	EXACT,		/* EXACT */
	EXACT,		/* EXACTF */
	EXACT,		/* EXACTFL */
	NOTHING,		/* NOTHING */
	NOTHING,		/* TAIL */
	STAR,		/* STAR */
	PLUS,		/* PLUS */
	CURLY,		/* CURLY */
	CURLY,		/* CURLYN */
	CURLY,		/* CURLYM */
	CURLY,		/* CURLYX */
	WHILEM,		/* WHILEM */
	OPEN,		/* OPEN */
	CLOSE,		/* CLOSE */
	REF,		/* REF */
	REF,		/* REFF */
	REF,		/* REFFL */
	BRANCHJ,		/* IFMATCH */
	BRANCHJ,		/* UNLESSM */
	BRANCHJ,		/* SUSPEND */
	BRANCHJ,		/* IFTHEN */
	GROUPP,		/* GROUPP */
	LONGJMP,		/* LONGJMP */
	BRANCHJ,		/* BRANCHJ */
	EVAL,		/* EVAL */
	MINMOD,		/* MINMOD */
	LOGICAL,		/* LOGICAL */
	BRANCHJ,		/* RENUM */
	NOTHING,		/* OPTIMIZED */
};
#endif


#ifdef REG_COMP_C
const static U8 regarglen[] = {
	0,		/* END */
	0,		/* SUCCEED */
	0,		/* BOL */
	0,		/* MBOL */
	0,		/* SBOL */
	0,		/* EOL */
	0,		/* MEOL */
	0,		/* SEOL */
	0,		/* BOUND */
	0,		/* BOUNDL */
	0,		/* NBOUND */
	0,		/* NBOUNDL */
	0,		/* GPOS */
	0,		/* ANY */
	0,		/* SANY */
	0,		/* ANYOF */
	0,		/* ALNUM */
	0,		/* ALNUML */
	0,		/* NALNUM */
	0,		/* NALNUML */
	0,		/* SPACE */
	0,		/* SPACEL */
	0,		/* NSPACE */
	0,		/* NSPACEL */
	0,		/* DIGIT */
	0,		/* NDIGIT */
	0,		/* BRANCH */
	0,		/* BACK */
	0,		/* EXACT */
	0,		/* EXACTF */
	0,		/* EXACTFL */
	0,		/* NOTHING */
	0,		/* TAIL */
	0,		/* STAR */
	0,		/* PLUS */
	EXTRA_SIZE(struct regnode_2),		/* CURLY */
	EXTRA_SIZE(struct regnode_2),		/* CURLYN */
	EXTRA_SIZE(struct regnode_2),		/* CURLYM */
	EXTRA_SIZE(struct regnode_2),		/* CURLYX */
	0,		/* WHILEM */
	EXTRA_SIZE(struct regnode_1),		/* OPEN */
	EXTRA_SIZE(struct regnode_1),		/* CLOSE */
	EXTRA_SIZE(struct regnode_1),		/* REF */
	EXTRA_SIZE(struct regnode_1),		/* REFF */
	EXTRA_SIZE(struct regnode_1),		/* REFFL */
	EXTRA_SIZE(struct regnode_1),		/* IFMATCH */
	EXTRA_SIZE(struct regnode_1),		/* UNLESSM */
	EXTRA_SIZE(struct regnode_1),		/* SUSPEND */
	EXTRA_SIZE(struct regnode_1),		/* IFTHEN */
	EXTRA_SIZE(struct regnode_1),		/* GROUPP */
	EXTRA_SIZE(struct regnode_1),		/* LONGJMP */
	EXTRA_SIZE(struct regnode_1),		/* BRANCHJ */
	EXTRA_SIZE(struct regnode_1),		/* EVAL */
	0,		/* MINMOD */
	0,		/* LOGICAL */
	EXTRA_SIZE(struct regnode_1),		/* RENUM */
	0,		/* OPTIMIZED */
};

const static char reg_off_by_arg[] = {
	0,		/* END */
	0,		/* SUCCEED */
	0,		/* BOL */
	0,		/* MBOL */
	0,		/* SBOL */
	0,		/* EOL */
	0,		/* MEOL */
	0,		/* SEOL */
	0,		/* BOUND */
	0,		/* BOUNDL */
	0,		/* NBOUND */
	0,		/* NBOUNDL */
	0,		/* GPOS */
	0,		/* ANY */
	0,		/* SANY */
	0,		/* ANYOF */
	0,		/* ALNUM */
	0,		/* ALNUML */
	0,		/* NALNUM */
	0,		/* NALNUML */
	0,		/* SPACE */
	0,		/* SPACEL */
	0,		/* NSPACE */
	0,		/* NSPACEL */
	0,		/* DIGIT */
	0,		/* NDIGIT */
	0,		/* BRANCH */
	0,		/* BACK */
	0,		/* EXACT */
	0,		/* EXACTF */
	0,		/* EXACTFL */
	0,		/* NOTHING */
	0,		/* TAIL */
	0,		/* STAR */
	0,		/* PLUS */
	0,		/* CURLY */
	0,		/* CURLYN */
	0,		/* CURLYM */
	0,		/* CURLYX */
	0,		/* WHILEM */
	0,		/* OPEN */
	0,		/* CLOSE */
	0,		/* REF */
	0,		/* REFF */
	0,		/* REFFL */
	2,		/* IFMATCH */
	2,		/* UNLESSM */
	1,		/* SUSPEND */
	1,		/* IFTHEN */
	0,		/* GROUPP */
	1,		/* LONGJMP */
	1,		/* BRANCHJ */
	0,		/* EVAL */
	0,		/* MINMOD */
	0,		/* LOGICAL */
	1,		/* RENUM */
	0,		/* OPTIMIZED */
};
#endif /* REG_COMP_C */

