#!/usr/bin/perl -w

#
# Modules - show information about modules and their maintainers
#

use strict;

use vars qw($Maintainers $Modules);

$Maintainers =
	{
	'ams'		=> 'Abhijit Menon-Sen <ams@wiw.org>',
	'andreas'	=> 'Andreas J. Koenig <andreas.koenig@anima.de>',
	'arthur'	=> 'Arthur Bergman <sky@nanisky.com>',
	'bbb'		=> 'Rob Brown <bbb@cpan.org>',
	'damian'	=> 'Damian Conway <damian@conway.org>',
	'dankogai'	=> 'Dan Kogai <dankogai@dan.co.jp>',
	'gbarr'		=> 'Graham Barr <gbarr@pobox.com>',
	'gisle'		=> 'Gisle Aas <gisle@activestate.com>',
	'ilyaz'		=> 'Ilya Zakharevich <ilyaz@cpan.org>',
	'jhi'		=> 'Jarkko Hietaniemi <jhi@iki.fi>',
	'jns'		=> 'Jonathan Stowe <jns@gellyfish.com>',
	'jvromans'	=> 'Johan Vromans <jvromans@squirrel.nl>',
	'lstein'	=> 'Lincoln D. Stein <lstein@cshl.org>',
	'mjd'		=> 'Mark-Jason Dominus <mjd@plover.com>',
	'muir'		=> 'David Muir Sharnoff <muir@idiom.com>',
	'neilb'		=> 'Neil Bowers <neil@bowers.com>',
	'rra'		=> 'Russ Allbery <rra@stanford.edu>',
	'pmarquess'	=> 'Paul Marquess <Paul.Marquess@btinternet.com>',
	'sadahiro'	=> 'SADAHIRO Tomoyuki <SADAHIRO@cpan.org>',
	'sburke'	=> 'Sean Burke <sburke@cpan.org>',
	'smcc'		=> 'Stephen McCamant <smcc@CSUA.Berkeley.EDU>',
	'schwern'	=> 'Michael Schwern <schwern@pobox.com>',
	'tels'		=> 'Tels a-t bloodgate.com',
	'tjenness'	=> 'Tim Jenness <t.jenness@jach.hawaii.edu>'
	};

$Modules = {

	'Attribute::Handlers' =>
		{
		'MAINTAINER'	=> 'arthur',
		'FILES'		=>
			q[lib/Attribute/Handlers.pm lib/Attribute/Handlers],
		},

	'B::Concise' =>
		{
		'MAINTAINER'	=> 'smcc',
		'FILES'		=> q[ext/B/B/Concise.pm ext/B/t/concise.t],
		},

	'bignum' =>
		{
		'MAINTAINER'	=> 'tels',
		'FILES'		=> q[lib/big{int,num,rat}.pm lib/bignum],
		},

	'CGI' =>
		{
		'MAINTAINER'	=> 'lstein',
		'FILES'		=> q[lib/CGI.pm lib/CGI],
		},

	'Class::ISA' =>
		{
		'MAINTAINER'	=> 'sburke',
		'FILES'		=> q[lib/Class/ISA.pm lib/Class/ISA],
		},

	'CPAN' =>
		{
		'MAINTAINER'	=> 'andreas',
		'FILES'		=> q[lib/CPAN.pm lib/CPAN],
		},

# Data::Dumper is not here, Sarathy has given up the maintenance
# and Data::Dumper should be considered a part of the Perl core.

	'DB::File' =>
		{
		'MAINTAINER'	=> 'pmarquess',
		'FILES'		=> q[ext/DB_File],
		},

	'Devel::PPPort' =>
		{
		'MAINTAINER'	=> 'pmarquess',
		'FILES'		=> q[ext/Devel/PPPort],
		},

	'Digest' =>
		{
		'MAINTAINER'	=> 'gisle',
		'FILES'		=> q[lib/Digest.{pm,t}],
		},

	'Digest::MD5' =>
		{
		'MAINTAINER'	=> 'gisle',
		'FILES'		=> q[ext/Digest/MD5],
		},

	'Encode' =>
		{
		'MAINTAINER'	=> 'dankogai',
		'FILES'		=> q[ext/Encode],
		},

# Errno is not here, Graham has given up the maintenance
# and Errno should be considered a part of the Perl core.

	'ExtUtils::MakeMaker' =>
		{
		'MAINTAINER'	=> 'schwern',
		'FILES'		=> q[lib/ExtUtils/MakeMaker],
		},

	'File::Temp' =>
		{
		'MAINTAINER'	=> 'tjenness',
		'FILES'		=> q[lib/File/Temp.pm lib/File/Temp],
		},

	'Filter::Simple' =>
		{
		'MAINTAINER'	=> 'damian',
		'FILES'		=> q[lib/Filter/Simple.pm lib/Filter/Simple],
		},

	'Filter::Util::Call' =>
		{
		'MAINTAINER'	=> 'pmarquess',
		'FILES'		=> q[ext/Filter/Util/Call],
		},

	'Getopt::Long' =>
		{
		'MAINTAINER'	=> 'jvromans',
		'FILES'		=> q[lib/Getopt/Long.pm lib/Getopt/Long],
		},

	'I18N::LangTags' =>
		{
		'MAINTAINER'	=> 'sburke',
		'FILES'		=> q[lib/I18N/LangTags.pm lib/I18N/LangTags],
		},

	'if' =>
		{
		'MAINTAINER'	=> 'ilyaz',
		'FILES'		=> q[lib/if.{pm,t}],
		},

# IO is not here, Graham has given up the maintenance
# and IO should be considered a part of the Perl core.

	'libnet' =>
		{
		'MAINTAINER'	=> 'gbarr',
		'FILES'		=>
			q[lib/Net/{Cmd,Domain,FTP,Netrc,NNTP,POP3,SMTP,Time}.pm lib/Net/ChangeLog.libnet lib/Net/FTP lib/Net/*.eg lib/Net/libnetFAQ.pod lib/Net/README.libnet lib/Net/t],
		},

	'Scalar-List-Util' =>
		{
		'MAINTAINER'	=> 'gbarr',
		'FILES'		=> q[ext/List/Util],
		},

	'Locale::Codes' =>
		{
		'MAINTAINER'	=> 'neilb',
		'FILES'		=> q[lib/Locale/{Codes,Constants,Country,Currency,Language,Script}*],
		},

	'Locale::Maketext' =>
		{
		'MAINTAINER'	=> 'sburke',
		'FILES'		=> q[lib/Locale/Maketext.pm lib/Locale/Maketext],
		},

	'Math::BigFloat' =>
		{
		'MAINTAINER'	=> 'tels',
		'FILES'		=> q[lib/Math/BigFloat.pm lib/Math/BigFloat],
		},

	'Math::BigInt' =>
		{
		'MAINTAINER'	=> 'tels',
		'FILES'		=> q[lib/Math/BigInt.pm lib/Math/BigInt],
		},

	'Math::BigRat' =>
		{
		'MAINTAINER'	=> 'tels',
		'FILES'		=> q[lib/Math/BigRat.pm lib/Math/BigRat],
		},

	'Memoize' =>
		{
		'MAINTAINER'	=> 'mjd',
		'FILES'		=> q[lib/Memoize.pm lib/Memoize],
		},

	'MIME::Base64' =>
		{
		'MAINTAINER'	=> 'gisle',
		'FILES'		=> q[ext/MIME/Base64],
		},

	'Net::Ping' =>
		{
		'MAINTAINER'	=> 'bbb',
		'FILES'		=> q[lib/Net/Ping.pm lib/Net/Ping],
		},

	'NEXT' =>
		{
		'MAINTAINER'	=> 'damian',
		'FILES'		=> q[lib/NEXT.pm lib/NEXT],
		},

# The PerlIO::* are part of Perl core.

	'podlators' =>
		{
		'MAINTAINER'	=> 'rra',
		'FILES'		=> q[lib/Pod/{Html,Man,ParseLink,Text,Text/{Color,Overstrike,Termcap}}.pm pod/pod2man.PL pod/pod2text.PL lib/Pod/t/{basic.*,{basic,man,parselink,text*}.t}],
		},

	'Storable' =>
		{
		'MAINTAINER'	=> 'ams',
		'FILES'		=> q[ext/Storable],
		},

	'Switch' =>
		{
		'MAINTAINER'	=> 'damian',
		'FILES'		=> q[lib/Switch.pm lib/Switch],
		},

	'TabsWrap' =>
		{
		'MAINTAINER'	=> 'muir',
		'FILES'		=>
			q[lib/Text/{Tabs,Wrap}.pm lib/Text/TabsWrap],
		},

	'Text::Balanced' =>
		{
		'MAINTAINER'	=> 'damian',
		'FILES'		=> q[lib/Text/Balanced.pm lib/Text/Balanced],
		},

	'Term::ANSIColor' =>
		{
		'MAINTAINER'	=> 'rra',
		'FILES'		=> q[lib/Term/ANSIColor.pm lib/Term/ANSIColor],
		},

	'Test::Builder' =>
		{
		'MAINTAINER'	=> 'schwern',
		'FILES'		=> q[lib/Test/Builder.pm],
		},

	'Test::Harness' =>
		{
		'MAINTAINER'	=> 'schwern',
		'FILES'		=> q[lib/Test/Harness.pm lib/Test/Harness],
		},

	'Test::More' =>
		{
		'MAINTAINER'	=> 'schwern',
		'FILES'		=> q[lib/Test/More.pm],
		},

	'Test::Simple' =>
		{
		'MAINTAINER'	=> 'schwern',
		'FILES'		=> q[lib/Test/Simple.pm lib/Test/Simple],
		},

	'Term::Cap' =>
		{
		'MAINTAINER'	=> 'jns',
		'FILES'		=> q[lib/Term/Cap.{pm,t}],
		},


	'threads' =>
		{
		'MAINTAINER' => 'arthur',
		'FILES'  => q[ext/threads],
		},

	'Tie::File' =>
		{
		'MAINTAINER'	=> 'mjd',
		'FILES'		=> q[lib/Tie/File.pm lib/Tie/File],
		},

	'Time::HiRes' =>
		{
		'MAINTAINER'	=> 'jhi',
		'FILES'		=> q[ext/Time/HiRes],
		},

	'Unicode::Collate' =>
		{
		'MAINTAINER'	=> 'sadahiro',
		'FILES'		=>
			q[lib/Unicode/Collate.pm lib/Unicode/Collate],
		},

	'Unicode::Normalize' =>
		{
		'MAINTAINER'	=> 'sadahiro',
		'FILES'		=> q[ext/Unicode/Normalize],
		},

	'warnings' =>
		{
		'MAINTAINER'	=> 'pmarquess',
		'FILES'		=>
		    q[warnings.pl lib/warnings.{pm,t}
		      lib/warnings t/lib/warnings],
		},

	};

use Getopt::Long;
use File::Find;

sub usage {
    print <<__EOF__;
$0: Usage: $0 [[--maintainer M --module M --files]|file ...]
$0 --maintainer M	list all maintainers matching M
$0 --module M		list all modules matching M
$0 --files		list all files of the module
Matching is case-ignoring regexp, author matching is both by
the short id and by the full name and email.
$0 file ...		list the module and maintainer
__EOF__
    exit(0);
}

my $Maintainer;
my $Module;
my $Files;

usage()
    unless
    GetOptions(
	       'maintainer=s'	=> \$Maintainer,
	       'module=s'	=> \$Module,
	       'files'		=> \$Files,
	       );

my @Files = @ARGV;

usage() if @Files && ($Maintainer || $Module || $Files);

for my $mean ($Maintainer, $Module) {
    warn "$0: Did you mean '$0 $mean'?\n"
	if $mean && -e $mean && $mean ne '.';
}

warn "$0: Did you mean '$0 -mo $Maintainer'?\n"
    if defined $Maintainer && exists $Modules->{$Maintainer};

warn "$0: Did you mean '$0 -ma $Module'?\n"
    if defined $Module     && exists $Maintainers->{$Module};

sub get_module_pat {
    my $m = shift;
    split ' ', $Modules->{$m}->{FILES};
}

sub get_module_files {
    my $m = shift;
    sort { lc $a cmp lc $b }
    map {
	-f $_ ? # Files as-is.
	    $_ :
	    -d _ ? # Recurse into directories.
	    do {
		my @files;
		find(
		     sub {
			 push @files, $File::Find::name
			     if -f $_;
		     }, $_);
		@files;
	    }
	: glob($_) # The rest are globbable patterns.
	} get_module_pat($m);
}

sub get_maintainer_modules {
    my $m = shift;
    sort { lc $a cmp lc $b }
    grep { $Modules->{$_}->{MAINTAINER} eq $m }
    keys %$Modules;
}

if ($Maintainer) {
    for my $m (sort keys %$Maintainers) {
	if ($m =~ /$Maintainer/io) {
	    my @modules = get_maintainer_modules($m);
	    if ($Module) {
		@modules = grep { /$Module/io } @modules;
	    }
	    if ($Files) {
		my @files;
		for my $module (@modules) {
		    push @files, get_module_files($module);
		}
		printf "%-15s @files\n", $m;
	    } else {
		if ($Module) {
		    printf "%-15s @modules\n", $m;
		} else {
		    printf "%-15s $Maintainers->{$m}\n", $m;
		}
	    }
	}
    }
} elsif ($Module) {
    for my $m (sort { lc $a cmp lc $b } keys %$Modules) {
	if ($m =~ /$Module/io) {
	    if ($Files) {
		my @files = get_module_files($m);
		printf "%-15s @files\n", $m;
	    } else {
		printf "%-15s $Modules->{$m}->{MAINTAINER}\n", $m;
	    }
	}
    }
} elsif (@Files) {
    my %ModuleByFile;

    @ModuleByFile{@Files} = ();

    # First try fast match.

    my %ModuleByPat;
    for my $module (keys %$Modules) {
	for my $pat (get_module_pat($module)) {
	    $ModuleByPat{$pat} = $module;
	}
    }
    # Expand any globs.
    my %ExpModuleByPat;
    for my $pat (keys %ModuleByPat) {
	if (-e $pat) {
	    $ExpModuleByPat{$pat} = $ModuleByPat{$pat};
	} else {
	    for my $exp (glob($pat)) {
		$ExpModuleByPat{$exp} = $ModuleByPat{$pat};
	    }
	}
    }
    %ModuleByPat = %ExpModuleByPat;
    for my $file (@Files) {
	$ModuleByFile{$file} = $ModuleByPat{$file}
	    if exists $ModuleByPat{$file};
    }

    # If still unresolved files..
    if (my @ToDo = grep { !defined $ModuleByFile{$_} } keys %ModuleByFile) {

	# Cannot match what isn't there.
	@ToDo = grep { -e $_ } @ToDo;

	if (@ToDo) {
	    # Try prefix matching.

	    # Remove trailing slashes.
	    for (@ToDo) { s|/$|| }

	    my %ToDo;
	    @ToDo{@ToDo} = ();

	    for my $pat (keys %ModuleByPat) {
		last unless keys %ToDo;
		if (-d $pat) {
		    my @Done;
		    for my $file (keys %ToDo) {
			if ($file =~ m|^$pat|i) {
			    $ModuleByFile{$file} = $ModuleByPat{$pat};
			    push @Done, $file;
			}
		    }
		    delete @ToDo{@Done};
		}
	    }
	}
    }

    for my $file (@Files) {
	if (defined $ModuleByFile{$file}) {
	    my $module     = $ModuleByFile{$file};
	    my $maintainer = $Modules->{$ModuleByFile{$file}}->{MAINTAINER};
	    printf "%-15s $module $maintainer $Maintainers->{$maintainer}\n", $file;
	} else {
	    printf "%-15s ?\n", $file;
	}
    }
}

exit(0);
