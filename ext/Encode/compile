#!../../perl -w
BEGIN {
    @INC = '../../lib';
    $ENV{PATH} .= ';../..' if $^O eq 'MSWin32';
}
use strict;
use Getopt::Std;
my @orig_ARGV = @ARGV;
my $perforce  = '$Id$';


sub encode_U
{
 # UTF-8 encode long hand - only covers part of perl's range
 my $uv = shift;
 if ($uv < 0x80)
  {
   return chr($uv)
  }
 if ($uv < 0x800)
  {
   return chr(($uv >> 6)        | 0xC0).
          chr(($uv & 0x3F)      | 0x80);
  }
 return chr(($uv >> 12)         | 0xE0).
        chr((($uv >> 6) & 0x3F) | 0x80).
        chr(($uv & 0x3F)        | 0x80);
}

sub encode_S
{
 # encode single byte
 my ($ch,$page) = @_;
 return chr($ch);
}

sub encode_D
{
 # encode double byte MS byte first
 my ($ch,$page) = @_;
 return chr($page).chr($ch);
}

sub encode_M
{
 # encode Multi-byte - single for 0..255 otherwise double
 my ($ch,$page) = @_;
 return &encode_D if $page;
 return &encode_S;
}

# Win32 does not expand globs on command line
eval "\@ARGV = map(glob(\$_),\@ARGV)" if ($^O eq 'MSWin32');

my %opt;
getopts('qo:f:n:',\%opt);
my $cname = (exists $opt{'o'}) ? $opt{'o'} : shift(@ARGV);
chmod(0666,$cname) if -f $cname && !-w $cname;
open(C,">$cname") || die "Cannot open $cname:$!";


my $dname = $cname;
$dname =~ s/(\.[^\.]*)?$/.def/;

my ($doC,$doEnc,$doUcm,$doPet);

if ($cname =~ /\.(c|xs)$/)
 {
  $doC = 1;
  chmod(0666,$dname) if -f $cname && !-w $dname;
  open(D,">$dname") || die "Cannot open $dname:$!";
  my $hname = $cname;
  $hname =~ s/(\.[^\.]*)?$/.h/;
  chmod(0666,$hname) if -f $cname && !-w $hname;
  open(H,">$hname") || die "Cannot open $hname:$!";

  foreach my $fh (\*C,\*D,\*H)
  {
   print $fh <<"END" unless $opt{'q'};
/*
 !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 This file was autogenerated by:
 $^X $0 $cname @orig_ARGV
 (Repository $perforce)
*/
END
  }

  if ($cname =~ /(\w+)\.xs$/)
   {
    print C "#include <EXTERN.h>\n";
    print C "#include <perl.h>\n";
    print C "#include <XSUB.h>\n";
    print C "#define U8 U8\n";
   }
  print C "#include \"encode.h\"\n";
 }
elsif ($cname =~ /\.enc$/)
 {
  $doEnc = 1;
 }
elsif ($cname =~ /\.ucm$/)
 {
  $doUcm = 1;
 }
elsif ($cname =~ /\.pet$/)
 {
  $doPet = 1;
 }

my @encfiles;
if (exists $opt{'f'})
 {
  # -F is followed by name of file containing list of filenames
  my $flist = $opt{'f'};
  open(FLIST,$flist) || die "Cannot open $flist:$!";
  chomp(@encfiles = <FLIST>);
  close(FLIST);
 }
else
 {
  @encfiles = @ARGV;
 }

my %encoding;
my %strings;

sub cmp_name
{
 if ($a =~ /^.*-(\d+)/)
  {
   my $an = $1;
   if ($b =~ /^.*-(\d+)/)
    {
     my $r = $an <=> $1;
     return $r if $r;
    }
  }
 return $a cmp $b;
}


foreach my $enc (sort cmp_name @encfiles)
 {
  my ($name,$sfx) = $enc =~ /^.*?([\w-]+)\.(enc|ucm)$/;
  $name = delete $opt{'n'} if exists $opt{'n'};
  if (open(E,$enc))
   {
    if ($sfx eq 'enc')
     {
      compile_enc(\*E,lc($name));
     }
    else
     {
      compile_ucm(\*E,lc($name));
     }
   }
  else
   {
    warn "Cannot open $enc for $name:$!";
   }
 }

if ($doC)
 {
  foreach my $name (sort cmp_name keys %encoding)
   {
    my ($e2u,$u2e,$erep,$min_el,$max_el) = @{$encoding{$name}};
    output(\*C,$name.'_utf8',$e2u);
    output(\*C,'utf8_'.$name,$u2e);
    push(@{$encoding{$name}},outstring(\*C,$e2u->{Cname}.'_def',$erep));
   }
  foreach my $enc (sort cmp_name keys %encoding)
   {
    my ($e2u,$u2e,$rep,$min_el,$max_el,$rsym) = @{$encoding{$enc}};
    my @info = ($e2u->{Cname},$u2e->{Cname},$rsym,length($rep),$min_el,$max_el);
    my $sym = "${enc}_encoding";
    $sym =~ s/\W+/_/g;
    print C "encode_t $sym = \n";
    print C " {",join(',',@info,"{\"$enc\",(const char *)0}"),"};\n\n";
   }

  foreach my $enc (sort cmp_name keys %encoding)
   {
    my $sym = "${enc}_encoding";
    $sym =~ s/\W+/_/g;
    print H "extern encode_t $sym;\n";
    print D " Encode_Define(aTHX_ &$sym);\n";
   }

  if ($cname =~ /(\w+)\.xs$/)
   {
    my $mod = $1;
    print C "\nMODULE = Encode::$mod\tPACKAGE = Encode::$mod\n\n";
    print C "BOOT:\n{\n";
    print C "#include \"$dname\"\n";
    print C "}\n";
   }
  close(D);
  close(H);
 }
elsif ($doEnc)
 {
  foreach my $name (sort cmp_name keys %encoding)
   {
    my ($e2u,$u2e,$erep,$min_el,$max_el) = @{$encoding{$name}};
    output_enc(\*C,$name,$e2u);
   }
 }
elsif ($doUcm)
 {
  foreach my $name (sort cmp_name keys %encoding)
   {
    my ($e2u,$u2e,$erep,$min_el,$max_el) = @{$encoding{$name}};
    output_ucm(\*C,$name,$u2e,$erep,$min_el,$max_el);
   }
 }

close(C);


sub compile_ucm
{
 my ($fh,$name) = @_;
 my $e2u = {};
 my $u2e = {};
 my $cs;
 my %attr;
 while (<$fh>)
  {
   s/#.*$//;
   last if /^\s*CHARMAP\s*$/i;
   if (/^\s*<(\w+)>\s+"?([^"]*)"?\s*$/i)
    {
     $attr{$1} = $2;
    }
  }
 if (!defined($cs =  $attr{'code_set_name'}))
  {
   warn "No <code_set_name> in $name\n";
  }
 else
  {
   # $name = lc($cs);
  }
 my $erep;
 my $urep;
 my $max_el;
 my $min_el;
 if (exists $attr{'subchar'})
  {
   my @byte;
   $attr{'subchar'} =~ /^\s*/cg;
   push(@byte,$1) while $attr{'subchar'} =~ /\G\\x([0-9a-f]+)/icg;
   $erep = join('',map(chr(hex($_)),@byte));
  }
 print "Scanning $name ($cs)\n";
 my $nfb = 0;
 my $hfb = 0;
 while (<$fh>)
  {
   s/#.*$//;
   last if /^\s*END\s+CHARMAP\s*$/i;
   next if /^\s*$/;
   my ($u,@byte);
   my $fb = '';
   $u = $1 if (/^<U([0-9a-f]+)>\s+/igc);
   push(@byte,$1) while /\G\\x([0-9a-f]+)/igc;
   $fb = $1 if /\G\s*(\|[0-3])/gc;
   # warn "$_: $u @byte | $fb\n";
   die "Bad line:$_" unless /\G\s*(#.*)?$/gc;
   if (defined($u))
    {
     my $uch = encode_U(hex($u));
     my $ech = join('',map(chr(hex($_)),@byte));
     my $el  = length($ech);
     $max_el = $el if (!defined($max_el) || $el > $max_el);
     $min_el = $el if (!defined($min_el) || $el < $min_el);
     if (length($fb))
      {
       $fb = substr($fb,1);
       $hfb++;
      }
     else
      {
       $nfb++;
       $fb = '0';
      }
     # $fb is fallback flag
     # 0 - round trip safe
     # 1 - fallback for unicode -> enc
     # 2 - skip sub-char mapping
     # 3 - fallback enc -> unicode
     enter($u2e,$uch,$ech,$u2e,$fb+0) if ($fb =~ /[01]/);
     enter($e2u,$ech,$uch,$e2u,$fb+0) if ($fb =~ /[03]/);
    }
   else
    {
     warn $_;
    }
  }
 if ($nfb && $hfb)
  {
   die "$nfb entries without fallback, $hfb entries with\n";
  }
 $encoding{$name} = [$e2u,$u2e,$erep,$min_el,$max_el];
}

sub compile_enc
{
 my ($fh,$name) = @_;
 my $e2u = {};
 my $u2e = {};

 my $type;
 while ($type = <$fh>)
  {
   last if $type !~ /^\s*#/;
  }
 chomp($type);
 return if $type eq 'E';
 my ($def,$sym,$pages) = split(/\s+/,scalar(<$fh>));
 warn "$type encoded $name\n";
 my $rep = '';
 my $min_el;
 my $max_el;
 {
  my $v = hex($def);
  no strict 'refs';
  $rep = &{"encode_$type"}($v & 0xFF, ($v >> 8) & 0xffe);
 }
 my %seen;
 while ($pages--)
  {
   my $line = <$fh>;
   chomp($line);
   my $page = hex($line);
   my $ch = 0;
   for (my $i = 0; $i < 16; $i++)
    {
     my $line = <$fh>;
     for (my $j = 0; $j < 16; $j++)
      {
       no strict 'refs';
       my $ech = &{"encode_$type"}($ch,$page);
       my $val = hex(substr($line,0,4,''));
       next if $val == 0xFFFD;
       if ($val || (!$ch && !$page))
        {
         my $el  = length($ech);
         $max_el = $el if (!defined($max_el) || $el > $max_el);
         $min_el = $el if (!defined($min_el) || $el < $min_el);
         my $uch = encode_U($val);
         if (exists $seen{$uch})
          {
           warn sprintf("U%04X is %02X%02X and %02X%02X\n",
                        $val,$page,$ch,@{$seen{$uch}});
          }
         else
          {
           $seen{$uch} = [$page,$ch];
          }
         enter($e2u,$ech,$uch,$e2u,0);
         enter($u2e,$uch,$ech,$u2e,0);
        }
       else
        {
         # No character at this position
         # enter($e2u,$ech,undef,$e2u);
        }
       $ch++;
      }
    }
  }
 $encoding{$name} = [$e2u,$u2e,$rep,$min_el,$max_el];
}

sub enter
{
 my ($a,$s,$d,$t,$fb) = @_;
 $t = $a if @_ < 4;
 my $b = substr($s,0,1);
 my $e = $a->{$b};
 unless ($e)
  {     # 0  1  2  3         4  5
   $e = [$b,$b,'',{},length($s),0,$fb];
   $a->{$b} = $e;
  }
 if (length($s) > 1)
  {
   enter($e->[3],substr($s,1),$d,$t,$fb);
  }
 else
  {
   $e->[2] = $d;
   $e->[3] = $t;
   $e->[5] = length($d);
  }
}

sub outstring
{
 my ($fh,$name,$s) = @_;
 my $sym = $strings{$s};
 unless ($sym)
  {
   foreach my $o (keys %strings)
    {
     my $i = index($o,$s);
     if ($i >= 0)
      {
       $sym = $strings{$o};
       $sym .= sprintf("+0x%02x",$i) if ($i);
       return $sym;
      }
    }
   $strings{$s} = $sym = $name;
   printf $fh "\nstatic const U8 %s[%d] =\n",$name,length($s);
   # Do in chunks of 16 chars to constrain line length
   # Assumes ANSI C adjacent string litteral concatenation
   while (length($s))
    {
     my $c = substr($s,0,16,'');
     print  $fh '"',join('',map(sprintf('\x%02x',ord($_)),split(//,$c))),'"';
     print  $fh "\n" if length($s);
    }
   printf $fh ";\n";
  }
 return $sym;
}

sub process
{
 my ($name,$a) = @_;
 $name =~ s/\W+/_/g;
 $a->{Cname} = $name;
 my @keys = grep(ref($a->{$_}),sort keys %$a);
 my $l;
 my @ent;
 foreach my $b (@keys)
  {
   my ($s,$f,$out,$t,$end) = @{$a->{$b}};
   if (defined($l) &&
       ord($b) == ord($a->{$l}[1])+1 &&
       $a->{$l}[3] == $a->{$b}[3] &&
       $a->{$l}[4] == $a->{$b}[4] &&
       $a->{$l}[5] == $a->{$b}[5] &&
       $a->{$l}[6] == $a->{$b}[6]
       # && length($a->{$l}[2]) < 16
      )
    {
     my $i = ord($b)-ord($a->{$l}[0]);
     $a->{$l}[1]  = $b;
     $a->{$l}[2] .= $a->{$b}[2];
    }
   else
    {
     $l = $b;
     push(@ent,$b);
    }
   if (exists $t->{Cname})
    {
     $t->{'Forward'} = 1 if $t != $a;
    }
   else
    {
     process(sprintf("%s_%02x",$name,ord($s)),$t);
    }
  }
 if (ord($keys[-1]) < 255)
  {
   my $t = chr(ord($keys[-1])+1);
   $a->{$t} = [$t,chr(255),undef,$a,0,0];
   push(@ent,$t);
  }
 $a->{'Entries'} = \@ent;
}

sub outtable
{
 my ($fh,$a) = @_;
 my $name = $a->{'Cname'};
 # String tables
 foreach my $b (@{$a->{'Entries'}})
  {
   next unless $a->{$b}[5];
   my $s = ord($a->{$b}[0]);
   my $e = ord($a->{$b}[1]);
   outstring($fh,sprintf("%s__%02x_%02x",$name,$s,$e),$a->{$b}[2]);
  }
 if ($a->{'Forward'})
  {
   print $fh "\nstatic encpage_t $name\[",scalar(@{$a->{'Entries'}}),"];\n";
  }
 $a->{'Done'} = 1;
 foreach my $b (@{$a->{'Entries'}})
  {
   my ($s,$e,$out,$t,$end,$l) = @{$a->{$b}};
   outtable($fh,$t) unless $t->{'Done'};
  }
 print $fh "\nstatic encpage_t $name\[",scalar(@{$a->{'Entries'}}),"] = {\n";
 foreach my $b (@{$a->{'Entries'}})
  {
   my ($s,$e,$out,$t,$end,$l,$fb) = @{$a->{$b}};
   my $sc = ord($s);
   my $ec = ord($e);
   $end |= 0x80 if $fb;
   print  $fh "{";
   if ($l)
    {
     printf $fh outstring($fh,'',$out);
    }
   else
    {
     print  $fh "0";
    }
   print  $fh ",",$t->{Cname};
   printf $fh ",0x%02x,0x%02x,$l,$end},\n",$sc,$ec;
  }
 print $fh "};\n";
}

sub output
{
 my ($fh,$name,$a) = @_;
 process($name,$a);
 # Sub-tables
 outtable($fh,$a);
}

sub output_enc
{
 my ($fh,$name,$a) = @_;
 foreach my $b (sort keys %$a)
  {
   my ($s,$e,$out,$t,$end,$l,$fb) = @{$a->{$b}};
  }
}

sub decode_U
{
 my $s = shift;
}

my @uname;
sub char_names
{
 my $s = do "unicode/Name.pl";
 pos($s) = 0;
 while ($s =~ /\G([0-9a-f]+)\t([0-9a-f]*)\t(.*?)\s*\n/igc)
  {
   my $name = $3;
   my $s = hex($1);
   last if $s >= 0x10000;
   my $e = length($2) ? hex($2) : $s;
   for (my $i = $s; $i <= $e; $i++)
    {
     $uname[$i] = $name;
#    print sprintf("U%04X $name\n",$i);
    }
  }
}

sub output_ucm_page
{
 my ($cmap,$a,$t,$pre) = @_;
 # warn sprintf("Page %x\n",$pre);
 foreach my $b (sort keys %$t)
  {
   my ($s,$e,$out,$n,$end,$l,$fb) = @{$t->{$b}};
   die "oops $s $e" unless $s eq $e;
   my $u = ord($s);
   if ($n != $a && $n != $t)
    {
     output_ucm_page($cmap,$a,$n,(($pre|($u &0x3F)) << 6)&0xFFFF);
    }
   elsif (length($out))
    {
     if ($pre)
      {
       $u = $pre|($u &0x3f);
      }
     my $s = sprintf "<U%04X> ",$u;
     foreach my $c (split(//,$out))
      {
       $s .= sprintf "\\x%02X",ord($c);
      }
     $s .= sprintf " |%d # %s\n",($fb ? 1 : 0),$uname[$u];
     push(@$cmap,$s);
    }
   else
    {
     warn join(',',@{$t->{$b}},$a,$t);
    }
  }
}

sub output_ucm
{
 my ($fh,$name,$h,$rep,$min_el,$max_el) = @_;
 print $fh "# Written $perforce\n# $0 @orig_ARGV\n" unless $opt{'q'};
 print $fh "<code_set_name> \"$name\"\n";
 char_names();
 if (defined $min_el)
  {
   print $fh "<mb_cur_min> $min_el\n";
  }
 if (defined $max_el)
  {
   print $fh "<mb_cur_max> $max_el\n";
  }
 if (defined $rep)
  {
   print $fh "<subchar> ";
   foreach my $c (split(//,$rep))
    {
     printf $fh "\\x%02X",ord($c);
    }
   print $fh "\n";
  }
 my @cmap;
 output_ucm_page(\@cmap,$h,$h,0);
 print $fh "#\nCHARMAP\n";
 foreach my $line (sort { substr($a,8) cmp substr($b,8) } @cmap)
  {
   print $fh $line;
  }
 print $fh "END CHARMAP\n";
}

